
\subsection{Some Complexity Classes}

\todo[inline]{references - cite Papadimitriou (book) for general;
Papadimitriou 1994 for PPAD}

A {\em computational problem} is given by the combination of an {\em input}
and a related {\em output}. A specific input gives an {\em instance} of the
problem.

Computational problems can be classified according to the form of their
output. A {\em function problem} $P$ returns for an intance $x$ an output
$y$ that satisfies a given binary relation $R(x,y)$. In the case of a
{\em decision problems}, $y$ is either ``YES'' or ``NO''. The
{\em complement} of a decision problem $P$ is the problem $\bar{P}$
that returns ``NO'' for each instance of $P$ that returns ``YES'', and
vice versa.

{\em Search problems} are function problems that return either an output
$y$ such that $R(x,y)$, or ``NO'', if it's not
possible to find any such $y$. If $y$ is guaranteed to exist, the problem
is called a {\em total function problem}. {\em Counting problems}
return the {\em number} of $y$'s that satisfy $R(x,y)$; given a problem
$R$ we denote the associated counting problem $\# R$.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it possible that there isn't
any Euler of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.'' Finally, a counting problem
is ``(input) given a graph, (output) return the number of its Euler tours.''

Computational problems are also classified according to their
{\em computational complexity}, given by the {\em reducibility} from each
other.

\todo[inline]{Turing machines: here - not that in the following deterministic
TM}

Let $P_1$ be a computational problem. For an instance $x$ of $P_1$, let
$|x|$ be the the number of bits needed to encode $x$. $P_1$
{\em reduces to the problem $P_2$ in polynomial time}, denoted
$P_1\leq_P P_2$, if there exists a {\em polynomial-time reduction}, that is,
a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$

\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $C$ is the {\em complement class} $\mathrm{co-C}$.
A problem $P$ is {\em hard} for a class $\mathrm{C}$ if for every problem
$P_C$ in $\mathrm{C}$ there is a polynomial-time reduction to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
$\mathrm{C}-hard$ problem in $\mathrm{C}$ is {\em complete} for
$\mathrm{C}$.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}, that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either ``YES'' or
``NO''  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial. Intuitively, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem.

A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that

\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies $|y|\leq p_1(|x|)$;
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}

This means that a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.

\todo[inline]{check formal def of \# P (?)}

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduce the classes
$\mathrm{\mathbf{FNP}}$, {\em function non-deterministic polynomial}, and
$\mathrm{\mathbf{TFNP}}$, {\em total function non-deterministic polynomial}.
The former is defined as the class of binary relations $R(x,y)$ such that
there is a polynomial-time algorithm that decides whether $R(x,y)$ holds
for given $x,y$ satisfying $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist. Intuitively, $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ are
similar to $\mathrm{\mathbf{NP}}$, but they allow for problems of
(respectively) function and total function form.

In \cite{megiddo-papad}, Megiddo and Papadimitriou also prove that, unless
$\mathrm{\mathbf{NP}}=\mathrm{\mathbf{co-NP}}$, it's impossible to find a
$\mathrm{\mathbf{TFNP}}$-complete problem.
% sketch of proof: in Julian's thesis. Needed? Going OT?

To study some problems in $\mathrm{\mathbf{TFNP}}$, Papadimitriou
(\cite{ppad}) introduced

\todo[inline]{

definition of PPA(D)
}

\subsection{Normal Form Games and Nash Equilibria}


\todo[inline]{n-NASH in TFNP & typical problem pushing the def of PPAD
(\cite{ppad}); in fact, PPAD-complete (\cite{dgp} for $n\geq 3$, \cite{cd}
for $n=2$).}
