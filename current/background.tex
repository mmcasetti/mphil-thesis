
\subsection{Some Complexity Classes}

\todo[inline]{references - cite Papadimitriou (book) for general;
Papadimitriou 1994 for PPAD}

A {\em computational problem} is given by the combination of an {\em input}
and a related {\em output}. A specific input gives an {\em instance} of the
problem.

Computational problems can be classified according to the form of their
output. A {\em function problem} $P$ returns for an intance $x$ an output
$y$ that satisfies a given binary relation $R(x,y)$. In the case of a
{\em decision problems}, $y$ is either ``YES'' or ``NO''. The
{\em complement} of a decision problem $P$ is the problem $\bar{P}$
that returns ``NO'' for each instance of $P$ that returns ``YES'', and
vice versa.

{\em Search problems} are function problems that return either an output
$y$ such that $R(x,y)$, or ``NO'', if it's not
possible to find any such $y$. If $y$ is guaranteed to exist, the problem
is called a {\em total function problem}. {\em Counting problems}
return the {\em number} of $y$'s that satisfy $R(x,y)$; given a problem
$R$ we denote the associated counting problem $\# R$.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it possible that there isn't
any Euler of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.'' Finally, a counting problem
is ``(input) given a graph, (output) return the number of its Euler tours.''

Computational problems are also classified according to their
{\em computational complexity}, given by the {\em reducibility} from each
other.

\todo[inline]{Turing machines: here - not that in the following deterministic
TM}

Let $P_1$ be a computational problem. For an instance $x$ of $P_1$, let
$|x|$ be the the number of bits needed to encode $x$. $P_1$
{\em reduces to the problem $P_2$ in polynomial time}, denoted
$P_1\leq_P P_2$, if there exists a {\em polynomial-time reduction}, that is,
a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$

\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $C$ is the {\em complement class} $\mathrm{co-C}$.
A problem $P$ is {\em hard} for a class $\mathrm{C}$ if for every problem
$P_C$ in $\mathrm{C}$ there is a polynomial-time reduction to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
$\mathrm{C}-hard$ problem in $\mathrm{C}$ is {\em complete} for
$\mathrm{C}$.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}, that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either ``YES'' or
``NO''  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial. Intuitively, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem.

A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that

\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies $|y|\leq p_1(|x|)$;
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}

This means that a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.

\todo[inline]{check formal def of \# P (?)}

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduce the classes
$\mathrm{\mathbf{FNP}}$, {\em function non-deterministic polynomial}, and
$\mathrm{\mathbf{TFNP}}$, {\em total function non-deterministic polynomial}.
The former is defined as the class of binary relations $R(x,y)$ such that
there is a polynomial-time algorithm that decides whether $R(x,y)$ holds
for given $x,y$ satisfying $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist. Intuitively, $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ are
similar to $\mathrm{\mathbf{NP}}$, but they allow for problems of
(respectively) function and total function form.

In \cite{megiddo-papad}, Megiddo and Papadimitriou also prove that, unless
$\mathrm{\mathbf{NP}}=\mathrm{\mathbf{co-NP}}$, it's impossible to find a
$\mathrm{\mathbf{TFNP}}$-complete problem.
To circumvent this limitation of $\mathrm{\mathbf{TFNP}}$, Papadimitriou
(\cite{ppad}) focused on the problems for which the existence of a solution
is proved by a ``parity argument'', introducing the classes
$\mathrm{\mathbf{PPA}}$ ({\em Proof by Parity Argument}) and
$\mathrm{\mathbf{PPAD}}$ ({\em Proof by Parity Argument, Directed version}).

\todo[inline]{definition of PPA(D): one in Papadimitriou 1994 and one in DGP
the second w END OF THE LINE, use that one.}

\todo[inline]{as an example, BROUWER, SPERNER (look at Papadimitriou 1994)}

\subsection{Normal Form Games and Nash Equilibria}

A {\em finite normal-form game} $\Gamma=(P,S,u)$,
where $S=\times_{p\in P} S_p$ and $u=\times_{p\in P} u^p$, and both
$P$ and $S$ are finite,
is a model of a strategic interaction.
Each {\em player} $p\in P$ chooses a probability distribution
$x^p=(x_1,\ldots,x_{|S_p|})$ over a set of {\em strategies} $s^p\in S_p$.
Since $x^p$ is a probability distribution, we have ${x_s}^p\geq 0$ and
$\sum_{s}{x_s}^p$ for every $p\in P$ and $s\in S_p$.
If ${x_s}^p = 0$ for every strategy $s^p$ but $\bar{s^p}$, the strategy
$x^p$ is the {\em pure strategy} $\bar{s^p}$; otherwise, $x^p$ is a
{\em mixed strategy}.
The {\em strategy profile} $(x^1,\ldots,x^{|P|})$ influences the
{\em payoff} $u^p: S\to\reals$ of each player $p$. For each player
$p$ we denote the set of strategy profiles of all his
opponents as $S_{-p}=\times_{q\neq p}{x_s}^q$, and for $s\in S_{-p}$ we
denote

\todo[inline]{(what exactly is this?!) as $x_s=\prod_{q\neq p} {x_{s_q}}^q$}

A {\em Nash equilibrium} of a game is a strategy profile in which each
player cannot improve his expected payoff by unilaterally changing his
strategy. Formally, a Nash equilibrium is a strategy profile $x$ such that
for every $p\in P$ and every $i,j\in S_p$
\[
\sum_{s\in S_{-p}} u^p(j,s) x_s > \sum_{s\in S_{-p}} u^p(k,s) x_s
\Rightarrow
{x_k}^p = 0
\]

The existence of a Nash equilibrium is guaranteed by the following theorem
by Nash (\cite{nash}).

\begin{theorem}\label{nash-thm}(Nash, \cite{nash})
Every finite game in normal form has a Nash equilibrium.
\end{theorem}

\todo[inline]{sketch of pf, brouwer}

\todo[inline]{as example, (generalised) matching pennies, used in DGP, incl
appendix here}

\todo[inline]{n-NASH in TFNP and typical problem pushing the def of PPAD
(\cite{ppad}); in fact, PPAD-complete (\cite{dgp} for $n\geq 3$, \cite{cd}
for $n=2$).}
