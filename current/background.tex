
\subsection{Some Complexity Classes}

\todo[inline]{reference - take Papadimitriou (book) for general, then article
Megiddo and Papadimitriou (1991) for (T)FNP and Papadimitriou 1994 for PPAD}

A {\em computational problem} is given by the combination of an {\em input}
and a related {\em output}. A specific input gives an {\em instance} of the
problem.

\todo[inline]{complement of a problem - needed for co-NP}

Computational problems can be classified according to the form of their
output. A {\em function problem} $P$ returns for an intance $x$ an output
$y$ that satisfies a given binary relation $R(x,y)$. In the case of a
{\em decision problems}, $y$ is either ``YES'' or ``NO''. The
{\em complement} of a decision problem $P$ is the problem $\bar{P}$
that returns ``NO'' for each instance of $P$ that returns ``YES'', and
vice versa.

{\em Search problems} are function problems that return either an output
$y$ such that $R(x,y)$, or ``NO'', if it's not
possible to find any such $y$. If $y$ is guaranteed to exist, the problem
is called a {\em total function problem}. {\em Counting problems}
return the {\em number} of $y$'s that satisfy $R(x,y)$; given a problem
$R$ we denote the associated counting problem $\# R$.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it possible that there isn't
any Euler of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.'' Finally, a counting problem
is ``(input) given a graph, (output) return the number of its Euler tours.''

Computational problems are also classified according to their
{\em computational complexity}, given by the {\em reducibility} from each
other.

\todo[inline]{Turing machines: here - not that in the following deterministic
TM}

Let $P_1$ be a computational problem. For an instance $x$ of $P_1$, let
$|x|$ be the the number of bits needed to encode $x$. $P_1$
{\em reduces to the problem $P_2$ in polynomial time}, denoted
$P_1\leq_P P_2$, if there exists a {\em polynomial-time reduction}, that is,
a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$

\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

For any class $C$ of decision problems, the class of all complements of
the problems in $C$ is the {\em complement class} $co-C$.

\todo[inline]{C-completeness}

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}, that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either ``YES'' or
``NO''  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial. Intuitively, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem.

A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that

\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies $|y|\leq p_1(|x|)$;
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}

Intuitively: a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem. A problem is
in the class $\mathrm{\mathbf{co-NP}}$ if its em complement is in
$\mathrm{\mathbf{NP}}$.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems of
counting the number of possible certificates for a problem in
$\mathrm{\mathbf{NP}}$.

\todo[inline]{check formal def of \# P}

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduce the classes
$\mathrm{\mathbf{FNP}}$,
{\em function non-deterministic polynomial}, and $\mathrm{\mathbf{TFNP}}$,
{\em total function non-deterministic polynomial}. The former is defined
as the class of binary relations $R(x,y)$ such that there is a
polynomial-time algorithm that decides whether $R(x,y)$ holds for
given $x,y$ satisfying $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist.
That is, $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ are analogous
to $\mathrm{\mathbf{NP}}$, but they allow for problems of (respectively)
function and total function form.


\todo[inline]{

More on TFNP: no complete pbls unless NP=co-NP (def co-NP)

$\Rightarrow$

definition of PPA(D)
}

\subsection{Normal Form Games and Nash Equilibria}
