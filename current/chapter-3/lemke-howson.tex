\section{The Lemke-Howson Algorithm}
\label{lh-section}

Let $P$ be a simple $d$-polytope with $n$ facets.
We {\em pivot on the vertices} of $P$ by moving from a
vertex $x$ to another vertex $y$ connected to $x$ by an edge.
Note that, since $P$ is simple, there are exactly
$d$ possible choices for $y$.
Analogously, we {\em pivot on the facets} of a simplicial polytope $Q$ in
dimension $d$ by moving from a facet $F$ to a facet $G$ that share
all vertices but one; since $Q$ is simplicial, there are $d$ possible
choices for $G$.

Suppose now that there is a labeling $l_f:[n]\to [d]$ of the facets of the
simple polytope $P$.
If we pivot from a vertex $x$ to a vertex $x'$ we ``leave behind'' a facet $F$
with label $k$; so, if $x$ has labels $(l_1,\ldots,k,\ldots,l_d)$, then
$x'$ has labels $(l_1,\ldots,h,\ldots,l_d)$, where $h$ is the label of the
facet $F'$ that does not have $x$ as its vertex. We call this
{\em dropping label $k$ and picking up label $h$}, or
{\em pivoting on label $k$}; see Figure \ref{pivot-vertex-fig}.
Analogously, if there is a labeling $l_v:[n]\to [d]$ of the vertices
of the simplicial poytope $Q$
and we pivot from a facet $F$ with labels $(l_1,\ldots,k,\ldots,l_d)$
to a facet $F'$ with labels $(l_1,\ldots,h,\ldots,l_d)$, we say that we
{\em drop label $k$ and pick up label $h$}, or that we
{\em pivot on label $k$}; see Figure \ref{pivot-facet-fig}.

\begin{figure}[hp]
\strut\hfill
\includegraphics[width=45ex]{chapter-3/fig-lh/cube-1-pivot.pdf}%
\hfill\strut
\caption[Pivoting on the vertices]{%
A pivot on the vertices of the cube.
}
\label{pivot-vertex-fig}
\end{figure}

\begin{figure}[hp]
\strut\hfill
\includegraphics[width=55ex]{chapter-3/fig-lh/octahedron-1-pivot.pdf}%
\hfill\strut
\caption[Pivoting on the facets]{%
A pivot on the facets of the octahedron.
}
\label{pivot-facet-fig}
\end{figure}

\clearpage

Let $m,n\in \naturals$ with $m\leq n$; consider a set $X$
and a labeling $l:X\to [m]$. The $n$-uple $x=(x_1,\ldots,x_n)\in X^n$
is {\em almost completely labeled} if there is exactly one $k\in [m]$ such
that
$\{ j\in [m]\ \mid\ x_i=j\text{ for some }i\in [n] \}= [m]\setminus \{ k \}$.
That is, an $n$-uple $x$ is almost completely labeled if all labels appear
once in $x$ except for the {\em missing label} $k\in [m]$ and the
{\em duplicate label} $h\in [m]$ that appears twice.
It's easy to see that if we pivot from an almost completely labeled facet
(or vertex) on the duplicate label, or from a completely labeled facet (or
vertex) on any label, we reach either an almost completely labeled or a
completely labeled facet (or vertex).

\begin{algorithm}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{
A simple $d$-polytope $P$ with $n$ facets.
A labeling $l_f:[n]\to [d]$ of the facets of $P$.
A vertex $x_0$ of $P$, completely labeled for $l$.
}
\Output{
A completely labeled vertex $x\neq x_0$ of $P$.
}
\BlankLine
choose any label $k\in [d]$ \\
pivot on label $k$ from $x_0$ to $x$ \\
\While{ $x$ is not completely labeled }
{
pivot on the duplicate label $h$ from $x$ to $x'\neq x_0$  \\
set $x_0 = x$, $x = x'$
}
\Return $x$
\caption{Lemke-Howson}
\label{lh-alg}
\end{algorithm}

The classic Lemke-Howson Algorithm \ref{lh-alg}, first introduced by
Lemke and Howson \cite{lh}, employs pivoting on the vertices of a simple
polytope, moving through a succession of almost completely
labeled vertices with missing label $k$; these vertices can be seen as
steps of a path, called {\em Lemke path}. We will use Lemke paths to prove
some fundamental properties of both the Lemke-Howson Algorithm and
the problem {\sc Another Completely Labeled Vertex}.

\begin{proposition}\label{lh-works-ppa-thm}
The Lemke-Howson Algorithm \ref{lh-alg} returns a solution
to the {\bf PPA} problem {\sc Another Completely Labeled Vertex}.

Furthermore, the number of completely labeled vertices in a simple
polytope with labeled facets is even.

\begin{proof}
We first show that the Lemke-Howson Algorithm works.
Let $x'$ be an almost completely labeled vertex of the Lemke path with
duplicate label $h$. There are only two facets with duplicate label $h$
that contain $x$; since $P$ is simple, each one of which corresponds to
exactly an edge.
One of these edges has been traversed to get to $x'$, the
other edge will be traversed to leave $x'$ in the next step. Therefore,
there are no ``loops'' where a vertex is visited more than once; the
Lemke paths are {\em simple}.

The parity is proven by the following argument: each Lemke path is
uniquely determined by its missing label and its starting point, so the
Lemke path from the endpoint with the same missing label will lead back
to the starting point. Since the endpoint and the starting point are
different, the Lemke paths must connect an even number of points.

Finally, for each label $k\in [d]$ chosen in line 1 of
Algorithm \ref{lh-alg}, the Lemke paths are disjoint paths connecting
all the completely labeled vertices of $P$, with a standard endpoint $x_0$.
The problem {\sc Another Completely Labeled Vertex} correspond to finding
a non-standard endpoints of this graph, which is a {\bf PPA} problem.
\end{proof}
\end{proposition}

Applying the parity result of Proposition \ref{lh-works-ppa-thm} to the
case of a bimatrix game (not necessarily a unit vector game), and
remembering that the point $(\0,\0)$ corresponds to the
``artificial'' equilibrium, we have the following result, due to Lemke and
Howson \cite{lh}.

\begin{theorem}{\rm (Lemke-Howson \cite{lh})}
Every non-degenerate bimatrix game has an odd number of Nash equilibria.
\end{theorem}

There are two ways of using the Lemke-Howson Algorithm to find a Nash
equilibrium of a bimatrix game $(A,B)$.
The first one is to ``symmetrize'' the game as in Proposition
\ref{symmetrize-c}. Let
$S = \{ z\in\reals^{m+n}\ |\ z\geq\0,\ Cz\leq\1 \}$ be the
polytope associated to the game $(C,C\T)$, where $C=\binom{0\ A}{B\T\ 0}$.
The facets of $C$ correspond to $2(m+n)$ inequalities; we label both
the $i$-th and the $(m+n+i)$-th inequality as $i\in [m+n]$ and we apply the
Lemke-Howson Algorithm starting from the vertex $\0$. This returns a Nash
equilibrium $(z,z)$ of $C$, which corresponds to a Nash equilibrium
$(x,y)=z$ of $(A,B)$.
We can also follow the ``traditional'' version of the Lemke-Howson
Algorithm alternating a move on the best response polytopes $P$ and a move
on the best response polytope $Q$ of (\ref{br-polytopes}).
Since the polytopes $P$ and $Q$ are in $\reals^m$ and $\reals^n$, whereas $S$
is a polytope in $\reals^{m+n}$, this second version is much easier to
visualize.

\begin{example}
Consider the $3\times 3$ game $(A,B)$ of Example \ref{br-game-ex}.
\begin{equation*}
A = \left(\begin{matrix}1&0&0\\ 0&1&0\\
0&0&1\end{matrix}\right),
\qquad
B = \left(\begin{matrix}0&2&4\\ 3&2&0\\
0&2&0\end{matrix}\right).
\end{equation*}
The best response polytopes can be represented as the best response regions
of Figure \ref{br-regions-fig} extended to the origin $\0$, as in Figure
\ref{lh-path-fig}.
The path starts in $(\0,\0)$; we drop the label 2 and we move on the polytope
$P$. The label 6 is duplicate; so we drop it and we make the next move on the
polytope $Q$, and so on until we reach the point $x$, that is the only Nash
equilibrium of $(A,B)$.
\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=65ex]{chapter-3/fig-lh/lh.pdf}%
\hfill\strut
\caption[A Lemke path for a bimatrix game]{%
Lemke path for missing label 2 on the best response polytopes $P$ (left)
and $Q$ (right) of game (\ref{AB}).
}
\label{lh-path-fig}
\end{figure}
\end{example}

The dual version of the Lemke-Howson Algorithm \ref{lh-alg}
and of proposition \ref{lh-works-ppa-thm} is quite straightforward.
\begin{algorithm}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{
A simplicial $m$-polytope $Q$ with $n$ vertices.
A labeling $l_v:[n]\to [d]$ of the vertices of $P$.
A vertex $F_0$ of $Q$, completely labeled for $l$.
}
\Output{
A completely labeled facet $F\neq F_0$ of $Q$.
}
\BlankLine
choose any label $k\in [d]$ \\
pivot on label $k$ from $F_0$ to $F$ \\
\While{ $x$ is not completely labeled }
{
pivot on the duplicate label $h$ from $F$ to $F'\neq x_0$  \\
set $F_0 = x$, $F = F'$
}
\Return $x$
\caption{Dual Lemke-Howson}
\label{lh-dual-alg}
\end{algorithm}

\begin{proposition}\label{lh-dual-works-ppa-thm}
The Dual Lemke-Howson Algorithm \ref{lh-dual-alg} returns
a solution to the {\bf PPA} problem {\sc Another Completely Labeled Facet}.

Furthermore, the number of completely labeled facets
in a simplicial polytope with labeled vertices is even.
\end{proposition}

By Theorem \ref{unit-vector-thm} and Theorem \ref{unit-vector-dual-thm},
in the case of unit vector games it is enough to apply the Lemke-Howson
Algorithm to the polytope
$P^l= \{ x\in\reals^m\ \mid\ x\geq\0,\ B\T x\leq\1 \}$ in (\ref{p-l}),
or the Dual Lemke-Howson Algorithm to the polytope
$Q=\conv(\{ e_1,\ldots,e_m \})\ \cup\ \{ c_1,\ldots,c_n \})$ in
(\ref{p-l-dual}).
The following theorem by Savani and von Stengel \cite{uvg} guarantees that
not only this yield a Nash equilibrium, but no potential solutions
are ``lost'' considering the polytope $P^l$ with $m$ labels
instead of the product of polytopes $P\times Q$ with $m + n$ labels;
an analogous result holds for the dual case.

\begin{theorem}\label{unit-paths}
Let $(U,B)$ be a unit vector game, with
$U=(e_{l(1)}\cdots e_{l(n)})$ for a labeling $l:[n]\to [m]$.
Let $P = \{ x\in\reals^m\ \mid\ x\geq\0,\ B\T x\leq\1 \}$ and
$Q = \{ y\in\reals^n\ \mid\ y\geq\0,\ A y\leq\1 \}$ as
in (\ref{br-polytopes}); let
$P^l= \{ x\in\reals^m\ \mid\ x\geq\0,\ B\T x\leq\1 \}$
as in (\ref{p-l}). Then for the missing label $k\in [m]$
the Lemke path on $P\times Q$ projects to a path on $P$ that corresponds
to the Lemke path on $P^l$ for the missing label $k$; for the missing label
$k=m+j$, where $j\in [n]$, the Lemke path on $P\times Q$ projects to a
path on $Q$ that corresponds to the Lemke path on $P^l$ for the
missing label $l(j)$.
\end{theorem}

We finally focus on the case of unit vector games where the simplicial
polytope $Q$ is cyclic, which we can study from the point of view of Gale
strings.
We will consider $s\in G(d,n)$, with $d$ even, as ``loops''.
Let $s(i)=1$ for an index $i\in [n]$; then, by Gale evenness condition,
there is an odd run of \1 's either on the left or on the right
of position $i$ in $s$; let $j$ be the first index after this run.
A {\em pivot on $s$} is given by setting $s(i)=0$ and $s(j)=1$.
If there is a labeling $l_s:[n]\to [m]$, we say that we
{\em pivot on label $l_s(i)$}, {\em dropping label $l_s(i)$} and
{\em picking up label $l_s(j)$}.
The {\em Lemke Howson for Gale Algorithm} is given as Algorithm \ref{lhg-alg}.

\begin{algorithm}\label{lhg-alg}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{
A labeling $l_s:[n]\to [d]$, where $d$ is even, such that there is a
completely labeled Gale string $s_0 \in G(d,n)$.
}
\Output{
A completely labeled Gale string $s\in G(d,n)$ such that $s\neq s_0$.
}
\BlankLine
choose a label $k\in [d]$ \\
pivot on label $k$ from $s_0$ to $s$ \\
\While{ $s$ is not completely labeled }
{
pivot on the duplicate label $h$ from $s$ to $s'\neq s_0$ \\
rename $s_0=s$, $s=s'$
}
\Return $s$
\caption{Lemke-Howson for Gale}
\label{lhg-alg}
\end{algorithm}

\newpage

The next example illustrates the correspondence between the
Lemke-Howson Algorithm and the Lemke-Howson for Gale Algorithm.

\begin{example}
Figure \ref{lhg-123432-fig} shows the cyclic polytope $C_4(6)$
with the labeling
\begin{eqnarray*}
l_v(i)= & i\quad & \text{ for }i\in [4]; \\
l_v(5)= & 3; & \\
l_v(6)= & 2. &
\end{eqnarray*}
This corresponds to the labeling $l_s$ for $G(4,6)$ given in
Example \ref{c46-123432-ex}, which gives the four completely labeled Gale
strings
$s_A=\1\1\1\100$, $s_B=\1\10\1\10$, $s_C=\100\1\1\1$ and
$s_D=\10\1\10\1$. These correspond to the facets $A$, $B$, $C$ and
$D$ of $C_4(6)$. Pivoting from $s_A=\1\1\1\100$ dropping label 3 returns
$s_B=\1\10\1\10$, analogously, pivoting from facet $A$ dropping
label 3 returns facet $B$.
\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=55ex]{chapter-3/fig-lh/123432-lh.pdf}%
\hfill
\small
\begin{tabular}{c | c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c }
{\footnotesize facet} & {\bf 1} & {\bf 2} & {\bf 3} & {\bf 4} & {\bf 3} & {\bf 2}\\
\hline
{\bf A} & \1 & \1 & $\underline{\1}$ & \1 & 0               & 0 \\
{\bf B} & \1 & \1 & 0                & \1 & $\overline{\1}$ & 0 \\
\hline
{\footnotesize facet} & {\bf 1} & {\bf 2} & {\bf 3} & {\bf 4} & {\bf 3} & {\bf 2}
\end{tabular}
\normalsize
\hfill\strut
\caption[A pivot on $G(4,6)$ and on $C_4(6)$]{%
The pivoting to $s_A=\1\1\1\1 00$ to $s_B=\1\10\1\10$ in the Lemke-Howson
for Gale Algorithm corresponds to the pivoting from facet $A$ to facet $B$
in the Dual Lemke-Howson Algorithm.%
}
\label{lhg-123432-fig}
\end{figure}
\end{example}

\newpage

In the case of Gale strings, it is quite easy to extend the proof of
Proposition \ref{lh-works-ppa-thm} and prove a stronger result of
{\bf PPAD} rather than just {\bf PPA} complexity.
We will do so by giving a {\em sign}, positive or negative,
to the completely labeled Gale strings, then proving that all the
endpoints of the Lemke paths have different sign. If the sign of the string
$s_0$ is positive, we can then orient the Lemke paths from positive to
negative, so that $s_0$ is a standard source; if the sign of the string $s_0$
is negative, we will give the opposite orientation.

A {\em permutation} of the elements of an ordered set $S$ is a sequence
without repetition of elements of $S$.
The {\em sign} of a permutation $\sigma$ is defined as
$\sign(\sigma)=(-1)^m$, where $m$ is the number of the exchanges of
exactly two elements of $\sigma$ (called {\em transpositions}) needed
to get $\sigma'=1\ldots n$ from $\sigma$. Note that any two permutations
that differ in only one transposition have opposite sign.
The {\em sign of a completely labeled Gale string} $s\in G(d,n)$ is defined
as follows. Let $l:[n]\to [d]$ be a labeling that completely labels $s$, and
let $l_0$ be the string of labels $l(i)$ such that $s(i)=1$ and that
two labels corresponding to a run in $l$ are adjacent in $l_0$. Then we
define $\sign(s)=\sign(l_0)$.
Note that if $l(i)=i$ for $i\in [d]$ then the sign of the completely
labeled Gale string $1^d 0^{(n-d)}$ is always positive.
Let $s\in G(d,n)$ be an almost completely labeled string for $l$ with
missing label $k$ and duplicate label $h$; let $i_1$ be the index of $h$
reached by the last pivot (the ``new'' position of $h$) and let $i_2$ be
the index of $h$ such that $s(i_2)=1$ before the last pivot (the ``old''
position). Let $l_1$ be the string obtained as $l_0$ substituting $k$ to
$h$ at index $i_1$, and let $l_2$ be the string obtained as $l_0$
substituting $k$ to $h$ at index $i_2$. Then $\sign(l_1)=-\sign(l_2)$,
since they can be obtained from each other by the transposition $(kh)$.
Consider now the steps of the Lemke-Howson for Gale Algorithm;
assume that $\sign(s_0)=+1$ (without loss of generality: the negative case
is symmetric). If the first pivot returns another completely labeled Gale
string $s'$, this must have negative sign because it has been obtained
``jumping'' over an odd number of \1's.
For the same reason, if the pivoting returns an almost completely labeled
Gale string, we have that $\sign(l_1)=-1$, so $\sign(l_2)=+1$.
The next pivoting step drops the label $h$ from index $i_2$, so again we
change sign.
Running the Lemke-Howson for Gale Algorithm will therefore result in sign
switching back and forth as in Table \ref{lhg-sign-figure}.
\begin{table}[hbt]
$\xymatrix@C=30mm@R-=5mm@M=3mm{
\text{\footnotesize completely labeled string} \ar[r]^{pivot}
    & \text{\footnotesize missing label in new position}  \ar[dl]|{=}  \\
\text{\footnotesize missing label in old position} \ar[r]^{pivot}
    & \qquad\qquad\cdots\qquad\qquad \ar[dl]|{=} \\
\qquad\qquad\cdots\qquad\qquad \ar[r]^{pivot}
    & \text{\footnotesize completely labeled string}
}$
\caption[Sign switching on the Lemke-Howson for Gale Algorithm]
{Sign switching on the Lemke-Howson for Gale Algorithm.}
\label{lhg-sign-figure}
\end{table}
Orienting all Lemke paths from positive to negative gives the {\bf PPAD}
complexity of \anothergale.



\begin{proposition}\label{lhg-works-thm}
The Lemke-Howson for Gale Algorithm \ref{lhg-alg} returns a
solution to the {\bf PPAD} problem \anothergale.

Furthermore, the number of completely labeled Gale strings
$s\in G(d,n)$, where $d$ is even, is even.
\end{proposition}


\begin{example}
Let $l_s=123432$; consider the Lemke path from the completely labeled
Gale string $s=\1\1\1\100$ dropping label $1$.
Figure \ref{lhg-sign-ex-figure} shows the graph of Table
\ref{lhg-sign-figure}. Note that $\sign(\10\1\10\1)=\sign((21)(34))$,
since $s(6)=s(1)=1$ and therefore the indices $6$ and $1$ are consecutive
in the same run.
\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=75ex]{chapter-3/fig-lh/pivoting-sign-example.pdf}%
\hfill\strut
\caption[An example of pivoting with sign]
{Pivoting with sign on $123432$.}
\label{lhg-sign-ex-figure}
\end{figure}
\end{example}

A result similar to Proposition \ref{gale-ppad-thm}, but more general, is given
in Shapley \cite{shapley}; it shows that two equilibria at the ends of a
Lemke path have opposite {\em index}. The index is defined in terms of the
signs of the determinants of the square submatries of the payoff matrices
for the equilibrium support; the artificial equilibrium is assigned
index $+1$. The main result of Shapley's article is that if a
nondegenerate game has $n$ Nash equilibria with index $+1$, then the game has
$n+1$ Nash equilibria with index $-1$. The article also gives an interesting
example of a game for which the graph of all Lemke paths is disjoint.
\begin{equation}
\label{disj-lp-game}
A = \left(
    \begin{matrix}
        2&2&0 \\
        0&3&0 \\
        3&0&1
    \end{matrix}
    \right),
\qquad
B = \left(
    \begin{matrix}
        3&0&2 \\
        0&3&2 \\
        0&0&1
    \end{matrix}
    \right),
\end{equation}
The equilibria of $(A,B)$ are $(x_1,y_1)=((0,0,1), (0,0,1))$,
$(x_2,y_2)=((0,1/2,1/2),(0,3/4,1/4))$ and
$(x_3,y_3)=((0,1,0),(0,1,0))$. All Lemke paths from the
artificial equilibrium $(0,0)$ end at $(x_1,y_1)$, and consequently all
other Lemke paths connect $(x_2,y_2)$ and $(x_3,y_3)$; see
Figure \ref{disj-lp-br-poly}.
\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=75ex]{chapter-3/fig-lh/shapley-game.pdf}%
\hfill\strut
\caption[Best response polytopes of a game with disjoint Lemke paths]{%
Best response polytopes of game \ref{disj-lp-game}.
}
\label{disj-lp-br-poly}
\end{figure}


An interesting example of the Lemke-Howson for Gale Algorithm is the
following, due to Morris \cite{morris}.

\begin{example}
\label{morris-ex}
Consider the labeling $l=1234564523$ for $G(6,10)$. The only two completely
labeled Gale string  are $s=\1\1\1\1\1\100$ and $s'=\1 00000\1\1\1\1\1$.
Figure \ref{morris-6-fig} shows the Lemke path for label 1.
\begin{figure}[hbt]
\begin{center}
\large
\begin{tabular}{c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c @{ } c }
{\bf 1} & {\bf 2} & {\bf 3} & {\bf 4} & {\bf 5} & {\bf 6} & {\bf 4} & {\bf 5} & {\bf 2} & {\bf 3} \\
\hline
\d1 & \1 & \1 & \1 & \1 & \1 & 0 & 0 & 0 & 0 \\
0 & \1 & \1 & \d1 & \1 & \1 & \u1 & 0 & 0 & 0 \\
0 & \1 & \1 & 0 & \d1 & \1 & \1 & \u1 & 0 & 0 \\
0 & \d1 & \1 & 0 & 0 & \1 & \1 & \1 & \u1 & 0 \\
0 & 0 & \1 & \u1 & 0 & \1 & \d1 & \1 & \1 & 0 \\
0 & 0 & \1 & \1 & \u1 & \1 & 0 & \d1 & \1 & 0 \\
0 & 0 & \d1 & \1 & \1 & \1 & 0 & 0 & \1 & \u1 \\
0 & 0 & 0 & \d1 & \1 & \1 & \u1 & 0 & \1 & \1 \\
0 & 0 & 0 & 0 & \d1 & \1 & \1 & \u1 & \1 & \1 \\
\u1 & 0 & 0 & 0 & 0 & \1 & \1 & \1 & \1 & \1 \\
\hline
{\bf 1} & {\bf 2} & {\bf 3} & {\bf 4} & {\bf 5} & {\bf 6} & {\bf 4} & {\bf 5} & {\bf 2} & {\bf 3} \\
\end{tabular}
\normalsize
\end{center}
\caption[The Morris path for $C(6,10)$]{The Morris path for $C(6,10)$.}
\label{morris-6-fig}
\end{figure}
\end{example}

Morris \cite{morris} proved that the length of the Lemke paths on the cyclic
polytope $C_d(2d)$ (therefore on Gale strings in $G(d,2d)$) with a labeling
analogous to the one in Example \ref{morris-ex} grows exponentially in $d$,
regardless of the label that is dropped. Morris' labeling, given for $d$ both
even and odd with some repetition that can be dropped without loss of
generality, is as follows:
\begin{eqnarray*}
l(k)=k          & \quad\quad\text{for }k\in [d];    \\
l(d+1)=d;       & \\
l(d+k)=d-k      & \quad\quad\text{for }2\leq k< d,\ k\text{ even };   \\
l(d+k)=d-k+2    & \quad\quad\text{for }2\leq k\leq d,\ k\text{ odd }; \\
l(2d)=1         & \quad\quad k\text{ even}.
\end{eqnarray*}

Savani and von Stengel \cite{svs} \cite{uvg} relied on Morris' example to
build different ``hard to solve'' games; these results give a strong
motivation to study the problem \anothergale\ to give a more precise proof
of this complexity. Our main result, in the next section, will give a
{\bf FP} algorithm that circumvents the problem of any exponential running
time of the Lemke-Howson for Gale Algorithm.
