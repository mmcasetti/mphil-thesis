\section{Computational Problems and Complexity}

A {\em deterministic Turing machine} $\mathcal{M}$ (we will imply the
``deterministic'' from now on) is a representation of an
{\em algorithm} that takes an {\em input}, runs a {\em program}
% all this was too garbled and you have to mention the "tape"
manipulating the input on a ``tape'', and returns an {\em
output} when it comes to a {\em halting state} $h$.
The halting state can be the {\em accepting state} with
output {\sc Yes} (the Turing machine {\em accepts} the
input), the {\em rejecting state} with output {\sc No} (the
Turing machine {\em rejects} the input). We denote the
output by $\mathcal{M}(x)$, which (if we are not just
dealing with a decision problem, see below) may be a string of symbols.  
Formally, $\mathcal{M}=(K,\Sigma,\delta,s)$, where the
finite set $K$ is the set of {\em states}; $\Sigma$ is a finite set of
{\em symbols} (the {\em alphabet} of $\mathcal{M}$) such that
$\Sigma\cap K=\varnothing$ and $\Sigma$ always contains the symbols
$\sqcup$ ({\em blank}) and $\rhd$ ({\em first symbol}).
% ... and omitted crucial details
The ``internal operation'' of the Turing machine is defined via
transitions on states and ``tape operations'' to write
symbols on a tape (for details see Papadimitriou
\cite{papad-cc}); it employs the {\em transition function}
\[
\delta:K\times \Sigma\longrightarrow (K\cup\{ h,\ \text{{\sc Yes}},\ \text{{\sc No}} \})%
\times \Sigma \times \{ \leftarrow,\rightarrow,- \}
\]
where $\{ \leftarrow,\rightarrow,- \}\nsubseteq(K\cup\Sigma)$ correspond to
the {\em cursor directions} for the tape ``left,'' ``right'' and ``stay.''

A {\em language} is a set of {\em strings} of symbols
$L\subseteq(\Sigma\setminus\{ \sqcup \})^\ast$; a {\em class} is a
set of languages. A Turing machine $\mathcal{M}$
{\em decides} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
either $\mathcal{M}(x)=\text{{\sc Yes}}$ if $x\in L$ or
$\mathcal{M}(x)=\text{{\sc No}}$ if $x\notin L$. If for every
$x\in (\Sigma\setminus\{ \sqcup \})^\ast$ either
$\mathcal{M}(x)=\text{{\sc Yes}}$ if and only if $x\in L$, or
$\mathcal{M}(x))=\text{{\sc No}}$ or $\mathcal M$
does not halt if and only if $x\notin L$, the Turing
machine $\mathcal{M}$ {\em accepts} $L$.
Finally, $\mathcal{M}$ {\em computes} a function
$f:(\Sigma\setminus\{ \sqcup \})^\ast\to\Sigma^\ast$ if
$\mathcal{M}(x)=f(x)$ for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$.

An {\em instance} is the specific input of a problem.
A problem $P$ that outputs either {\sc Yes} or {\sc No} is a
{\em decision problem}. Its {\em complement} is the problem $\overline{P}$
that outputs ``{\sc No}'' for each instance of $P$ that outputs
``{\sc Yes}'', and vice versa.
A {\em function problem} outputs a string more general than
{\sc Yes} or {\sc No}.
An instance $x$ of a {\em search problem} either returns a string $y$
that satisfies a given relation $R(x,y)$ or it
rejects the input if it is not possible to find any such string.
If $y$ is guaranteed to exist, the problem is a {\em total function problem}.
By Theorem \ref{nash-thm}, the problem $n$-Nash of Table \ref{n-nash} is a
total function problem.

\begin{problem}
{$n$-Nash}
{A $n$-player game.}
{A Nash equilibrium of the game.}
\label{n-nash}
\end{problem}

Let $P_1$ be a problem and let $x$ be an instance of $P_1$ that is encoded
in $|x|$ bits. $P_1$ {\em reduces to the problem $P_2$ in polynomial time}
if there exists a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$, a 
Turing machine $\mathcal{M}$, and a polynomial $p$
such that for all $x\in\{0,1\}^\ast$
\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps.
\end{enumerate}

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $\mathrm{C}$ is the {\em complement class}
$\mathrm{co-C}$. A problem $P$ is {\em hard} for a class $\mathrm{C}$
if every problem in $\mathrm{C}$ is polynomial-time reducible to $P$; that is,
if $P$ is at least as hard to solve as every problem in $\mathrm{C}$. A
{\em complete} problem for the class $\mathrm{C}$ is a $\mathrm{C}-hard$ problem
that is also in $\mathrm{C}$.
Intuitively, if $P_1$ is polynomial-time reducible to $P_2$, it takes
polynomial time to ``translate'' $P_1$ to $P_2$, and then to
``translate back'' a solution of $P_2$ as a solution of $P_1$.
This is particularly useful if $P_2$ is hard. Then
the problem $P_1$ is at least as ``difficult''. If $P_2$ is also complete,
it can be used as a test of belonging to its class.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}, that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either {\sc Yes} or
{\sc No}  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial.
A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that
\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
such that \mbox{$|y|\leq p_1(|x|)$};
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}
Informally, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem, and
a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible solutions for a problem in $\mathrm{\mathbf{NP}}$.
% there may be many different certificates for the same
% solution; \#P is for counting the solutions
Finally, the class {\bf PSPACE} is the set of decision
problems that are solved by a Turing machine requiring a
polynomial amount of tape space in the input size $n$.
The relation
$\mathbf{P}\subseteq \mathbf{NP}\subseteq \mathbf{PSPACE}$ holds, with
strict inclusions being an open problem. It is also still unknown if
\mbox{{\bf NP = co-NP}}.
