\section{Problems and Complexity}

A {\em deterministic Turing machine} $\mathcal{M}$ (we will imply the
``deterministic'' from now on) is a representation of an
{\em algorithm} that takes an {\em input}, runs a {\em program}
manipulating the input, and either does not come to a
{\em halting state} $h$ or it returns an {\em output}; the latter can
be the {\em accepting state} {\sc Yes} (the Turing machine {\em accepts} the
input), the {\em rejecting state} {\sc No} (the Turing machine {\em rejects}
the input), or a string $\mathcal{M}(x)$. Formally,
$\mathcal{M}=(K,\Sigma,\delta,s)$, where the
finite set $K$ is the set of {\em states}; $\Sigma$ is a finite set of
{\em symbols} (the {\em alphabet} of $\mathcal{M}$) such that
$\Sigma\cap K=\varnothing$ and $\Sigma$ always contains the symbols
$\sqcup$ ({\em blank}) and $\rhd$ ({\em first symbol}). The
{\em transition function} $\delta$ is
\[
\delta:K\times \Sigma\longrightarrow (K\cup\{ h,\ \text{{\sc Yes}},\ \text{{\sc No}} \})%
\times \Sigma \times \{ \leftarrow,\rightarrow,- \}.
\]
where $\{ \leftarrow,\rightarrow,- \}\nsubseteq(K\cup\Sigma)$ correspond to
the {\em cursor directions} ``left,'' ``right'' and ``stay.''

A {\em language} is a set of {\em strings} of symbols
$L\subseteq(\Sigma\setminus\{ \sqcup \})^\ast$; a {\em class} is a
set of languages. A Turing machine $\mathcal{M}$
{\em decides} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
either $\mathcal{M}(x)=\text{{\sc Yes}}$ if $x\in L$ or
$\mathcal{M}(x)=\text{{\sc No}}$ if $x\notin L$. If for every
$x\in (\Sigma\setminus\{ \sqcup \})^\ast$ either
$\mathcal{M}(x)=\text{{\sc Yes}}$, if and only if $x\in L$, or
$\mathcal{M}(x)$ does not halt, if and only if $x\notin L$, the Turing
machine $\mathcal{M}$ {\em accepts} $L$.
Finally, $\mathcal{M}$ {\em computes} a function
$f:(\Sigma\setminus\{ \sqcup \})^\ast\to\Sigma^\ast$ if
$\mathcal{M}(x)=f(x)$ for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$.

An {\em instance} is the specific input of a problem.
A problem $P$ that outputs either {\sc Yes} or {\sc No} is a
{\em decision problem}; its {\em complement} is the problem $\overline{P}$
that outputs ``{\sc No}'' for each instance of $P$ that outputs
``{\sc Yes}'', and vice versa;
a {\em function problem} outputs a string more generic than {\sc Yes} or
{\sc No}
An instance $x$ of a {\em search problem} either returns a string $y$
that satisfies a given relation $R(x,y)$ or it
rejects the input if it's not possible to find any such string;
if $y$ is guaranteed to exist, the problem is a {\em total function problem}.
By Theorem \ref{nash-thm}, the problem $n$-Nash of Table \ref{n-nash} is a
total function problem.

\begin{problem}
{$n$-Nash}
{A $n$-player game.}
{A Nash equilibrium of the game.}
\label{n-nash}
\end{problem}

Let $P_1$ be a problem and let $x$ be an instance of $P_1$ that is encoded
in $|x|$ bits. $P_1$ {\em reduces to the problem $P_2$ in polynomial time}
if there exists a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a
Turing machine $\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$
\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $\mathrm{C}$ is the {\em complement class}
$\mathrm{co-C}$. A problem $P$ is {\em hard} for a class $\mathrm{C}$
if every problem in $\mathrm{C}$ is polynomial-time reducible to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
{\em complete} for the class $\mathrm{C}$ is a $\mathrm{C}-hard$ problem
that is also in $\mathrm{C}$.
Intuitively, if $P_1$ is polynomial-time reducible to $P_2$, it takes
polynomial time to ``translate'' $P_1$ to $P_2$, and then to
``translate back'' a solution of $P_2$ as a solution of $P_1$.
This is particularly useful if $P_2$ is hard; then
the problem $P_1$ is at least as ``difficult''; if $P_2$ is also complete,
it can be used as a test of belonging to its class.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}; that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either {\sc Yes} or
{\sc No}  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial.
A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that
\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
such that \mbox{$|y|\leq p_1(|x|)$};
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}
Informally, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem, and
a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.
Finally, the class {\bf PSPACE} is the set of decision problem that are
solved by a Turing machine requiring a polynomial amount of space of
the input size $n$. The relation
$\mathbf{P}\subseteq \mathbf{NP}\subseteq \mathbf{PSPACE}$ holds, with
strict inclusions being an open problem; it is also still unknown if
\mbox{{\bf NP = co-NP}}.
