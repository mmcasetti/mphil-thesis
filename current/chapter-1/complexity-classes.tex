\section{Some Complexity Classes}

A {\em Turing machine} $\mathcal{M}$ is a representation of an
{\em algorithm} that takes an {\em input}, runs a {\em program}
manipulating the input, and either does not come to a
{\em halting state} or it returns an {\em output}; the latter can
be {\sc Yes} (in which case the Turing machine {\em accepts} the
input), {\sc No} (the Turing machine {\em rejects} the input), or a
string $\mathcal{M}(x)$. Formally, $\mathcal{M}=(K,\Sigma,\delta,s)$.
The finite set $K$ is the set of {\em states}; $\Sigma$ is a finite set of
{\em symbols} (the {\em alphabet} of $\mathcal{M}$) such that
$\Sigma\cap K=\varnothing$, and $\Sigma$ always contains the symbols
$\sqcup$ ({\em blank}) and $\rhd$ ({\em first symbol}). The
{\em transition function} $\delta$ is
\[
\delta:K\times \Sigma\longrightarrow (K\cup\{ h,\ \text{{\sc Yes}},\ \text{{\sc No}} \})%
\times \Sigma \times \{ \leftarrow,\rightarrow,- \}
\]
where $h$ is the {\em halting state}, {\sc Yes} is the {\em accepting state},
{\sc No} is the {\em rejecting state}, and
$\{ \leftarrow,\rightarrow,- \}\nsubseteq(K\cup\Sigma)$ correspond to
the {\em cursor directions} ``left,'' ``right'' and ``stay.''

A {\em language} is a set of strings of symbols
$L\subseteq(\Sigma\setminus\{ \sqcup \})^\ast$; a Turing machine $\mathcal{M}$
{\em decides} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
either $\mathcal{M}(x)=\text{{\sc Yes}}$ if $x\in L$ or
$\mathcal{M}(x)=\text{{\sc No}}$ if $x\notin L$.
We say that $\mathcal{M}$
{\em accepts} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
we have that $\mathcal{M}(x)=\text{{\sc Yes}}$ if $x\in L$ and
$\mathcal{M}(x)$ does not halt if $x\notin L$.
Given a function $f:(\Sigma\setminus\{ \sqcup \})^\ast\to\Sigma^\ast$,
we say that $\mathcal{M}$ {\em computes} $f$ if $\mathcal{M}(x)=f(x)$
for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$.
A {\em class} is a set of languages.

A specific input of a problem is called an {\em instance}.
If a problem $P$ outputs either {\sc Yes} or {\sc No}, $P$ is a
{\em decision problem}; its {\em complement} is the problem $\overline{P}$
that outputs ``{\sc No}''
for each instance of $P$ that outputs ``{\sc Yes}'', and vice versa.
A {\em function problem} outputs a string $y$, more generic than {\sc Yes} or
{\sc No}, that satisfies a binary relation $R(x,y)$, where $x$ is the
instance of $P$; a {\em search problem} either outputs $y$ as above or it
rejects the input if it's not possible to find any such $y$.
If $y$ is guaranteed to exist, the problem is called a
{\em total function problem}.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it possible that there isn't
any Euler of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.''

Let $P_1$ be a problem and let $x$ be an instance of $P_1$ that is encoded
in $|x|$ bits. $P_1$ {\em reduces to the problem $P_2$ in polynomial time},
denoted $P_1\leq_{\mathrm{P}} P_2$, if there exists a
{\em polynomial-time reduction},
that is, a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$
\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

Intuitively, if $P_1$ is polynomial-time reducible to $P_2$, it takes
polynomial time to ``translate'' $P_1$ to $P_2$, and then to
``translate back'' a solution of $P_2$ as a solution of $P_1$.
This is particularly useful if $P_2$ is ``difficult to solve''; then
the problem $P_1$ is at least as ``difficult.''

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $\mathrm{C}$ is the {\em complement class}
$\mathrm{co-C}$. A problem $P$ is {\em hard} for a class $\mathrm{C}$
if every problem in $\mathrm{C}$ is polynomial-time reducible to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
{\em complete} for the class $\mathrm{C}$ is a $\mathrm{C}-hard$ problem
that is also in $\mathrm{C}$.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}; that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either {\sc Yes} or
{\sc No}  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial. Intuitively, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem.
A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that
\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies \mbox{$|y|\leq p_1(|x|)$};
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}
Intuitively, a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduced the classes
$\mathrm{\mathbf{FNP}}$, {\em function non-deterministic polynomial}, and
$\mathrm{\mathbf{TFNP}}$, {\em total function non-deterministic polynomial}.
The former is defined as the class of binary relations $R(x,y)$ such that
there is a polynomial-time algorithm that decides $R(x,y)$
for $x,y$ such that $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist. $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ can be seen
as the equivalent of $\mathrm{\mathbf{NP}}$ for (respectively)
function and total function problems.
Also in \cite{megiddo-papad}, Megiddo and Papadimitriou proved that
$\mathrm{\mathbf{TFNP}}$ is a {\em semantic} class, that is,
a class without complete problems, unless
$\mathrm{\mathbf{NP}}=\mathrm{\mathbf{co-NP}}$.
To circumvent this limitation, Papadimitriou \cite{ppad} focused
on the problems for which the existence of a solution
is proved by a specific argument, introducing the classes
$\mathrm{\mathbf{PPA}}$ ({\em Proof by Parity Argument}) and
$\mathrm{\mathbf{PPAD}}$ ({\em Proof by Parity Argument, Directed version}).

The existence of a solution for a problem in {\bf PPA} can be proved
using the argument ``in any undirected graph with one odd-degree node
there must be another odd-degree node.'' It is
interesting to note that {\bf PPA}-complete problems are yet to be found.
Problems in {\bf PPAD}, on the other hand, are guaranteed to have a
solution by a proof employing the argument ``in any directed graph with
one unbalanced node (that is, with outdegree different from its
indegree) there must be another unbalanced node.'' This can be simplified
to the argument ``in any directed graph in which all vertices have
indegree and outdegree at most one, if there is a {\em source}
(a node with indegree zero), then there must be a {\em sink}
(a node with outdegree zero).''
Formally, we can define {\bf PPAD} as the class of problems reducible to
the problem {\sc End Of The Line}.
This is the definition given in Daskalakis, Goldberg and Papadimitriou
\cite{dgp}; the original definition in Papadimitriou \cite{ppad} is given
in terms of Turing machines.

\begin{fctproblem}
{End Of The Line}
{Two circuits $S$ and $P$ with $n$ input bits and $n$ output bits such that
$P(0^n)=0^n\neq S(0^n)$.}
{An input $x\in \{ 0,1 \}^n$ such that $P(S(x)\neq x)$ or
$S(P(x))\neq x\neq 0^n$}
\end{fctproblem}

A {\em circuit} is formally defined as a directed acyclic graph with $n$
vertices with indegree $0$ called {\em input nodes}, $m$ vertices with
outdegree $0$ called {\em output nodes}, and {\em internal nodes} with
indegree 1 or 2; when each input node receives an input in $\{ 0,1 \}$,
the internal nodes with indegree $2$ compute the Boolean functions $and$ or
$or$, the internal nodes with indegree $1$ compute the Boolean function
$not$ and each output node returns a value in $\{ 0,1 \}$ accordingly.
The problems in {\bf PPAD} can be seen as a circuit $S$ (``successor''),
and a circuit $P$ (``predecessor'') that are used to build a directed
graph with an edge $(x,y)$ if and only if $S(x)=y$ and $P(y)=x$, with a
{\em standard source} $0^n$; the output is either a sink or a
non-standard source.
Figure \ref{ppad-graph} presents an example of graph of a {\bf PPAD}
problem; a graph for a {\bf PPA} problem is analogous, but the resulting
graph is not directed and instead of sources and sinks there are
generic endpoints.

\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=70ex]{chapter-1/fig/PPAD.pdf}%
\hfill\strut
\caption[A PPAD problem]{%
In green, the circuit $S$; in red, the circuit $P$. The standard source
is the black node; the green nodes are the other sources; the red nodes are
the sinks. The graph can include paths, cycles and isolated points.
}
\label{ppad-graph}
\end{figure}

By theorem \ref{nash-thm}, the problem $n$-{\sc Nash}, defined as follows,
is a total function problem.

\begin{fctproblem}
{$n$-Nash}
{A $n$-player game.}
{A Nash equilibrium of the game.}
\end{fctproblem}

Megiddo and Papadimitriou (\cite{megiddo-papad}) proved that $n$-{\sc Nash}
is in {\bf TFNP}. Daskalakis, Goldberg and Papadimitriou \cite{dgp} and Chen
and Deng \cite{cd} have later proven its {\bf PPAD}-completeness, the
former for $n\geq 3$ and the latter for $n\geq 2$.
A small amendment of the proof in \cite{dgp} can be found in Casetti
\cite{msc-diss}.

\begin{theorem}{\rm (Daskalakis, Goldberg and Papadimitriou \cite{dgp};
Chen and Deng \cite{cd})}\label{nash-ppad-complete}
For $n\geq 2$, the problem {\sc $n$-Nash} is {\bf PPAD}-complete.
\end{theorem}

We will see more problems in {\bf PPA} and {\bf PPAD} in chapter
\ref{main-chapter}; in fact, our main result can be seen as a
negative result on the {\bf PPAD} complexity of a case of $2$-Nash.
