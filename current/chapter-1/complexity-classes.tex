\section{Some Complexity Classes}

A {\em Turing machine} $\mathcal{M}$ is a representation of a
{\em program} that takes an {\em input}, runs a {\em program}
manipulating the input, and either does not come to a
{\em halting state} or it returns an {\em output}; the latter can
be {\sc Yes} (in which case the Turing machine {\em accepts} the
input), {\sc No} (the Turing machine {\em rejects} the input), or a
string $\mathcal{M}(x)$. Formally, $\mathcal{M}=(K,\Sigma,\delta,s)$.
The finite set $K$ is the set of {\em states}; $\Sigma$ is a finite set of
{\em symbols} (the {\em alphabet} of $\mathcal{M}$) such that
$\Sigma\cap K=\varnothing$, and $\Sigma$ always contains the symbols
$\sqcup$ ({\em blank}) and $\rhd$ ({\em first symbol}); $\delta$ is the
{\em transition function}
\[
\delta:K\times \Sigma\longrightarrow (K\cup\{ h, {\sc Yes}, {\sc No} \})%
\times \Sigma \times \{ \leftarrow,\rightarrow,- \}
\]
where $h$ is the {\em halting state}, {\sc Yes} is the {\em accepting state},
{\em No} is the {\em rejecting state}, and
$\{ \leftarrow,\rightarrow,- \}\nsubseteq(K\cup\Sigma)$ correspond to
the {\em cursor directions} ``left,'' ``right'' and ``stay.''

A {\em language} is a set of strings of symbols
$L\subset(\Sigma\setminus\{ \sqcup \})^\ast$; a Turing machine $\mathcal{M}$
{\em decides} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
$\mathcal{M}(x)={\sc Yes}$ if $x\in L$ and
$\mathcal{M}(x)={\sc No}$ if $x\notin L$.
We say that $\mathcal{M}$
{\em accepts} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
$\mathcal{M}(x)={\sc Yes}$ if $x\in L$ and
$\mathcal{M}(x)$ does not halt if $x\notin L$.
Given a function $f:(\Sigma\setminus\{ \sqcup \})^\ast\to\Sigma^\ast$,
we say that $\mathcal{M}$ {\em computes} $f$ if for every
$x\in (\Sigma\setminus\{ \sqcup \})^\ast$ $\mathcal{M}(x)=f(x)$.

Given a problem, a specific input of a problem is called an {\em instance}.
The output of a {\em decision problem} $P$ is either {\sc Yes} or {\sc No}.
Its {\em complement} is the problem $\bar{P}$ that outputs ``{\sc No}''
for each instance of $P$ that outputs ``{\sc Yes}'', and vice versa.
A {\em function problem} outputs a more generic $y$ that satisfies
a binary relation $R(x,y)$, where $x$ is the instance of the problem.
{\em Search problems} are function problems that return either $y$ such
that $R(x,y)$, or ``{\sc No}'' if it's not possible to find any such $y$.
If $y$ is guaranteed to exist, the problem is called a
{\em total function problem}.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it possible that there isn't
any Euler of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.''

Let $P_1$ be a problem and let $x$ be an instance of $P_1$ that is encoded
in $|x|$ bits. $P_1$ {\em reduces to the problem $P_2$ in polynomial time},
denoted $P_1\leq_P P_2$, if there exists a {\em polynomial-time reduction},
that is, a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$
\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

Intuitively, if $P_1$ is polynomial-time reducible to $P_2$, it takes
polynomial time to ``translate'' $P_1$ to $P_2$, and then to
``translate back'' a solution of $P_2$ as a solution of $P_1$.
This is particularly useful if $P_2$ is ``difficult to solve''; then
the problem $P_1$ is at least as ``difficult.''

A {\em class} is a set of languages.
For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $\mathrm{C}$ is the {\em complement class}
$\mathrm{co-C}$. A problem $P$ is {\em hard} for a class $\mathrm{C}$
if for every problem $P_{\mathrm{C}}$ in $\mathrm{C}$ there is a
polynomial-time reduction to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
$\mathrm{C}-hard$ problem in $\mathrm{C}$ is {\em complete} for
$\mathrm{C}$.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}; that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either {\sc Yes} or
{\sc No}  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial. Intuitively, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem.
A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that
\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies $|y|\leq p_1(|x|)$;
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}
Intuitively, a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduced the classes
$\mathrm{\mathbf{FNP}}$, {\em function non-deterministic polynomial}, and
$\mathrm{\mathbf{TFNP}}$, {\em total function non-deterministic polynomial}.
The former is defined as the class of binary relations $R(x,y)$ such that
there is a polynomial-time algorithm that decides $R(x,y)$
for $x,y$ such that $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist. Intuitively, $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ are
similar to $\mathrm{\mathbf{NP}}$, but they allow for problems of
(respectively) function and total function form.
Also in \cite{megiddo-papad}, Megiddo and Papadimitriou proved that, unless
$\mathrm{\mathbf{NP}}=\mathrm{\mathbf{co-NP}}$, $\mathrm{\mathbf{TFNP}}$ is a
{\em semantic} class, that is, a class without complete problems.
To circumvent this limitation of $\mathrm{\mathbf{TFNP}}$, Papadimitriou
\cite{ppad} focused on the problems for which the existence of a solution
is proved by a ``parity argument'', introducing the classes
$\mathrm{\mathbf{PPA}}$ ({\em Proof by Parity Argument}) and
$\mathrm{\mathbf{PPAD}}$ ({\em Proof by Parity Argument, Directed version}).

Intuitively, {\bf PPA} is the class of problems for which the existence of
a solution can be proved using the argument ``in any undirected graph with
one odd-degree node there must be another odd-degree node.'' It is
interesting to note that no {\bf PPA} problems have been proven
{\bf PPA}-complete.
The existence of the problems in {\bf PPAD}, on the other hand, can be
proven using the argument ``in any directed graph with one unbalanced node
(that is, with outdegree different from its indegree) there must be another
unbalanced node.'' The latter can simplified without loss of generality or
computational power to the case of indegree and outdegree at most one,
that is, ``in any directed graph in which all vertices have indegree and
outdegree at most one, if there is a {\em source} (a node with indegree
zero), then there must be a {\em sink} (a node with outdegree zero).''
Formally, we can define {\bf PPAD} as the class of problems reducible to
the problem {\sc End Of The Line}.

\begin{fctproblem}
{End Of The Line}
{Two circuits $S$ and $P$ with $n$ input bits and $n$ output bits such that
$P(0^n)=0^n\neq S(0^n)$.}
{An input $x\in \{ 0,1 \}^n$ such that $P(S(x)\neq x)$ or
$S(P(x))\neq x\neq 0^n$}
\end{fctproblem}

This is the definition given in Daskalakis, Goldberg and Papadimitriou
\cite{dgp}; Papadimitriou \cite{ppad} defines the class in terms of Turing
machines.
A circuit is formally defined as a directed acyclic graph with $n$
vertices with indegree $0$ called {\em input nodes}, $m$ vertices with
outdegree $0$ called {\em output nodes}, and {\em internal nodes} with
indegree 1 or 2; when each input node receives an input in $\{ 0,1 \}$,
the internal nodes with indegree $2$ compute the Boolean functions $and$ or
$or$, the internal nodes with indegree $1$ compute the Boolean function
$not$ and each output node returns a value in $\{ 0,1 \}$ accordingly.
The problems in {\bf PPAD} can be seen as a circuit $S$ (``successor''),
and a circuit $P$ (``predecessor'') that are used to build a directed
graph with an edge $(x,y)$ if and only if $S(x)=y$ and $P(y)=x$, with a
{\em standard source} $0^n$; the output is either a sink or a
non-standard source. Problems in {\bf PPA} can be defined analogously,
such that the resulting graph is not directed and instead of sources and
sinks there are generic endpoints.
We have that
${\bf{\rm PPAD}}\subset{\bf{\rm PPA}}$, and there are {\bf PPA} problems
that are not {\bf PPAD}, as we will see in section \ref{lh-section}.
Figure \ref{ppad-graph} presents an example of graph of a {\bf PPAD}
problem; a graph for a {\bf PPA} problem is analogous, but undirected.

\begin{figure}[hbt]
\strut\hfill
\includegraphics[width=70ex]{chapter-1/fig/PPAD.pdf}%
\hfill\strut
\caption[A PPAD problem]{%
In green, the circuit $S$; in red, the circuit $P$. The standard source
is the black node; the green nodes are the other sources; the red nodes are
the sinks. The graph can include paths, cycles and isolated points.
}
\label{ppad-graph}
\end{figure}

By theorem \ref{nash-thm}, the problem $n$-{\sc Nash}, defined as follows,
is a total function problem.

\begin{fctproblem}
{$n$-Nash}
{A $n$-player game.}
{A Nash equilibrium of the game.}
\end{fctproblem}

Megiddo and Papadimitriou (\cite{megiddo-papad}) proved that it is
in {\bf TFNP}. Daskalakis, Goldberg and Papadimitriou \cite{dgp} and Chen
and Deng \cite{cd} have proven its {\bf PPAD}-completeness, the former for
$n\geq 3$ and the latter for $n\geq 2$.
A small amendment of the proof in \cite{dgp} can be found in Casetti
\cite{msc-diss}.

\begin{theorem}{\rm (Daskalakis, Goldberg and Papadimitriou \cite{dgp};
Chen and Deng \cite{cd})}\label{nash-ppad-complete}
For $n\geq 2$, the problem {\sc $n$-Nash} is {\bf PPAD}-complete.
\end{theorem}

We will see more problems in {\bf PPA} and {\bf PPAD} in chapter
\ref{main-chapter}; in fact, our main result can be seen as a
negative result on the {\bf PPAD} complexity of a case of $2$-Nash.
