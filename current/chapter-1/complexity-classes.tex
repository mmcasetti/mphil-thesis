\section{Some Complexity Classes}

A {\em deterministic Turing machine} $\mathcal{M}$ (we will imply the
``deterministic'' from now on) is a representation of an
{\em algorithm} that takes an {\em input}, runs a {\em program}
manipulating the input, and either does not come to a
{\em halting state} $h$ or it returns an {\em output}; the latter can
be the {\em accepting state} {\sc Yes} (the Turing machine {\em accepts} the
input), the {\em rejecting state} {\sc No} (the Turing machine {\em rejects}
the input), or a string $\mathcal{M}(x)$. Formally,
$\mathcal{M}=(K,\Sigma,\delta,s)$.
The finite set $K$ is the set of {\em states}; $\Sigma$ is a finite set of
{\em symbols} (the {\em alphabet} of $\mathcal{M}$) such that
$\Sigma\cap K=\varnothing$, and $\Sigma$ always contains the symbols
$\sqcup$ ({\em blank}) and $\rhd$ ({\em first symbol}). The
{\em transition function} $\delta$ is
\[
\delta:K\times \Sigma\longrightarrow (K\cup\{ h,\ \text{{\sc Yes}},\ \text{{\sc No}} \})%
\times \Sigma \times \{ \leftarrow,\rightarrow,- \}.
\]
where $\{ \leftarrow,\rightarrow,- \}\nsubseteq(K\cup\Sigma)$ correspond to
the {\em cursor directions} ``left,'' ``right'' and ``stay.''

A {\em language} is a set of strings of symbols
$L\subseteq(\Sigma\setminus\{ \sqcup \})^\ast$; a {\em class} is a
set of languages. A Turing machine $\mathcal{M}$
{\em decides} $L$ if for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$
either $\mathcal{M}(x)=\text{{\sc Yes}}$ if $x\in L$ or
$\mathcal{M}(x)=\text{{\sc No}}$ if $x\notin L$. If for every
$x\in (\Sigma\setminus\{ \sqcup \})^\ast$ either
$\mathcal{M}(x)=\text{{\sc Yes}}$, if and only if $x\in L$, or
$\mathcal{M}(x)$ does not halt, if and only if $x\notin L$, the Turing
machine $\mathcal{M}$ {\em accepts} $L$.
Finally, $\mathcal{M}$ {\em computes} a function
$f:(\Sigma\setminus\{ \sqcup \})^\ast\to\Sigma^\ast$ if
$\mathcal{M}(x)=f(x)$ for every $x\in (\Sigma\setminus\{ \sqcup \})^\ast$.

An {\em instance} is the specific input of a problem.
A problem $P$ that outputs either {\sc Yes} or {\sc No} is a
{\em decision problem}; its {\em complement} is the problem $\overline{P}$
that outputs ``{\sc No}'' for each instance of $P$ that outputs
``{\sc Yes}'', and vice versa.
A {\em function problem} outputs a string $y$ more generic than {\sc Yes} or
{\sc No}; a {\em search problem} either outputs a string $y$
rejects the input if it's not possible to find any such $y$.
If $y$ is guaranteed to exist, the problem is a {\em total function problem}.

An example of decision problem is: ``(input) given a graph, (question)
is it possible to find an Euler tour of the graph?'' Its complement
is ``(input) given a graph, (question) is it impossible to find any Euler
of the graph?'' A search problem is: ``(input) given a graph,
(output) return one Euler tour of the graph, or ``NO'' if no such tour
exists.'' A total function problem is: ``(input) given an Euler graph,
(output) return one of its Euler tours.''

Let $P_1$ be a problem and let $x$ be an instance of $P_1$ that is encoded
in $|x|$ bits. $P_1$ {\em reduces to the problem $P_2$ in polynomial time}
if there exists a {\em polynomial-time reduction},
that is, a function $f: \{0,1\}^\ast \to \{0,1\}^\ast$ and a Turing machine
$\mathcal{M}$ such that for all $x\in\{0,1\}^\ast$
\begin{enumerate}
\item $x\in P_1\quad\iff\quad f(x)\in P_2$;
\item $\mathcal{M}$ computes $f(x)$;
\item $\mathcal{M}$ stops after $p(|x|)$ steps, where $p$ is a polynomial.
\end{enumerate}

For any class $\mathrm{C}$ of decision problems, the class of all complements
of the problems in $\mathrm{C}$ is the {\em complement class}
$\mathrm{co-C}$. A problem $P$ is {\em hard} for a class $\mathrm{C}$
if every problem in $\mathrm{C}$ is polynomial-time reducible to $P$; that is,
if $P$ is hard to solve at least as every problem in $\mathrm{C}$. A
{\em complete} for the class $\mathrm{C}$ is a $\mathrm{C}-hard$ problem
that is also in $\mathrm{C}$.
Intuitively, if $P_1$ is polynomial-time reducible to $P_2$, it takes
polynomial time to ``translate'' $P_1$ to $P_2$, and then to
``translate back'' a solution of $P_2$ as a solution of $P_1$.
This is particularly useful if $P_2$ is hard; then
the problem $P_1$ is at least as ``difficult''; if $P_2$ is also complete,
it can be used as a test of belonging to its class.

The complexity class $\mathrm{\mathbf{P}}$ contains all the
{\em polynomially decidable problems}; that is, all problems $P$ such that
there exists a Turing machine $\mathcal{M}$ that outputs either {\sc Yes} or
{\sc No}  for all inputs $x\in\{0,1\}^\ast$ of $P$ after $p(|x|)$ steps,
where $p$ is a polynomial.
A problem $P$ belongs to the class $\mathrm{\mathbf{NP}}$,
{\em non-deterministic polynomial-time problems}, if there exists a
Turing machine $\mathcal{M}$ and polynomials $p_1,p_2$ such that
\begin{enumerate}
\item for all $x\in P$ there exists a {\em certificate} $y\in \{0,1\}^\ast$
which satisfies \mbox{$|y|\leq p_1(|x|)$};
\item $\mathcal{M}$ accepts the combined input $xy$, stopping after at most
$p_2(|x| + |y|)$ steps;
\item for all $x\notin P$ there does not exist $y\in \{0,1\}^\ast$ such
that $\mathcal{M}$ accepts the combined input $xy$.
\end{enumerate}
The class $\mathrm{\mathbf{\# P}}$ is the class of all problems that output
the number of possible certificates for a problem in $\mathrm{\mathbf{NP}}$.
Informally, a decision problem is in
$\mathrm{\mathbf{P}}$ if the answer to its question can be found in a
number of steps that is polynomial in the input of the problem, and
a decision problem is in $\mathrm{\mathbf{NP}}$ if it takes
polynomial time to verify whether the ``certificate solution'' $y$ is,
indeed, a correct answer to the question posed by the problem.
Finally, the class {\bf PSPACE} is the set of decision problem that are
solved by a Turing machine requiring a polynomial amount of space of
the input size $n$. The relation
$\mathbf{P}\subseteq \mathbf{NP}\subseteq \mathbf{PSPACE}$ holds, with
strict inclusions being an open problem.

In \cite{megiddo-papad}, Megiddo and Papadimitriou introduced the classes
$\mathrm{\mathbf{FNP}}$, {\em function non-deterministic polynomial}, and
$\mathrm{\mathbf{TFNP}}$, {\em total function non-deterministic polynomial}.
The former is defined as the class of binary relations $R(x,y)$ such that
there is a polynomial-time algorithm that decides $R(x,y)$
for $x,y$ such that $|y|\leq p(|x|)$, where $p$ is a polynomial. The
latter is the class of all such problems for which $y$ is guaranteed to
exist. $\mathrm{\mathbf{FNP}}$ and $\mathrm{\mathbf{TFNP}}$ can be seen
as the equivalent of $\mathrm{\mathbf{NP}}$ for (respectively)
function and total function problems.
Also in \cite{megiddo-papad}, Megiddo and Papadimitriou proved that
$\mathrm{\mathbf{TFNP}}$ is a {\em semantic} class, that is,
a class without complete problems, unless
$\mathrm{\mathbf{NP}}=\mathrm{\mathbf{co-NP}}$, which is to this day an open
problem. To circumvent this limitation, Papadimitriou \cite{ppad} focused
on the problems for which the existence of a solution
is proved by a specific argument, introducing the classes
$\mathrm{\mathbf{PPA}}$ ({\em Proof by Parity Argument}) and
$\mathrm{\mathbf{PPAD}}$ ({\em Proof by Parity Argument, Directed version}).

The existence of a solution for a problem in {\bf PPA} can be proved
using the argument ``in any undirected graph with one odd-degree node
there must be another odd-degree node.'' It is
interesting to notice that {\bf PPA}-complete problems are yet to be found.
Problems in {\bf PPAD}, analogously, are guaranteed to have a
solution by a proof employing the argument ``in any directed graph in
which all vertices have indegree and outdegree at most one where there is
a {\em source} (a node with indegree zero) there must be a {\em sink}
(a node with outdegree zero).''
Formally, we can define {\bf PPAD} as the class of problems reducible to
the problem {\sc End Of The Line} in Table \ref{eotl}.
This is the definition given in Daskalakis, Goldberg and Papadimitriou
\cite{dgp}; the original definition in Papadimitriou \cite{ppad} is given
in terms of Turing machines.
A {\em circuit} with $n$ {\em input bits} and $m$ {\em output bits} is a
function $C:\{ 0,1 \}^n\to \{ 0,1 \}^m$.

\begin{problem}
{End Of The Line}
{Two circuits $S$ and $P$ with $n$ input bits and $n$ output bits such that
$P(0^n)=0^n\neq S(0^n)$.}
{An input $x\in \{ 0,1 \}^n$ such that $P(S(x)\neq x)$ or
$S(P(x))\neq x\neq 0^n$}
\label{eotl}
\end{problem}

The problems in {\bf PPAD} can be seen as a circuit $S$ (``successor''),
and a circuit $P$ (``predecessor'') that are used to build a directed
graph with an edge $(x,y)$ if and only if $S(x)=y$ and $P(y)=x$; furthermore,
a {\em standard source} $0^n$ is given, guaranteeing the existence of the
output, which consists in either a sink or a non-standard source.
Figure \ref{ppad-graph} presents an example of a graph implicit in a
{\bf PPAD} problem; a graph for a {\bf PPA} problem is analogous, but
it is undirected and instead of sources and sinks there are
generic endpoints.

\begin{figure}[hbtp]
\strut\hfill
\includegraphics[width=70ex]{chapter-1/fig/PPAD.pdf}%
\hfill\strut
\caption[A PPAD problem]{%
The graph in a {\bf PPAD} problem (paths in black, cycles in blue, isolated
points in purple).
The input is given by the circuits $S$ (in green) and $P$ (in red) and
the standard source (the black node). The output can be either a sink
(a red node) or a nonstandard source (a green node).
}
\label{ppad-graph}
\end{figure}

\newpage

\begin{problem}
{$n$-Nash}
{A $n$-player game.}
{A Nash equilibrium of the game.}
\label{n-nash}
\end{problem}

By theorem \ref{nash-thm}, the problem $n$-{\sc Nash} of Table
\ref{n-nash} is a total function problem.
Megiddo and Papadimitriou (\cite{megiddo-papad}) proved that $n$-{\sc Nash}
is in {\bf TFNP}. Daskalakis, Goldberg and Papadimitriou \cite{dgp} and Chen
and Deng \cite{cd} have later proven its {\bf PPAD}-completeness, the
former for $n\geq 3$ and the latter for $n\geq 2$.
A small amendment of the proof in \cite{dgp} can be found in Casetti
\cite{msc-diss}.

\begin{theorem}{\rm (Daskalakis, Goldberg and Papadimitriou \cite{dgp};
Chen and Deng \cite{cd})}\label{nash-ppad-complete}
For $n\geq 2$, the problem {\sc $n$-Nash} is {\bf PPAD}-complete.
\end{theorem}

We will see more problems in {\bf PPA} and {\bf PPAD} in chapter
\ref{main-chapter}; in fact, our main result can be seen as a
negative result on the {\bf PPAD} complexity of a case of {\sc $2$-Nash}.
