%\documentclass[final,5p,times,twocolumn]{elsarticle}
\documentclass[preprint,12pt]{elsarticle}
\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{verbatim}
\usepackage[ruled,vlined, lined,linesnumbered]{algorithm2e}
\usepackage{graphicx}
\usepackage[all]{xy}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}



%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
%\usepackage[bottom]{draftcopy}

%\include{pstricks}
%\include{cases}

%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}


%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

%\journal{Operations Research Letters}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Finding Gale Strings}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \address[label1]{}
%% \address[label2]{}

\author{Marta M. Casetti, Julian Merschen, Bernhard von Stengel}

\address{Department of Mathematics, London School of Economics, Houghton Street,London WC2A 2AE, U.K.} \ead{m.m.casetti@lse.ac.uk, j.merschen@lse.ac.uk, stengel@maths.lse.ac.uk}

\begin{abstract}
The classical algorithm for finding an Nash Equilibrium, the Lemke-Howson algorithm, exhibits exponential running time for a special class of bimatrix games generated by dual cyclical polytopes.
It was thus conjectured that solving these games via the Lemke-Howson algorithm was PPAD-complete, which would give an elegant and traceable proof that \textsc{Nash} is PPAD-complete.
For this special class of games the Nash Equilibria can be fully described by Gale strings. We introduce the problems \textsc{Gale} and \textsc{Another Gale string} and show that both are polynomially solvable: this implies that finding all NE for these games can be solved in polynomial time, disproving the above conjecture.

%A Gale evenness string is a bit string  associated to a string of labels that satisfies certain regularity conditions. We prove that finding whether one such string exists is a problem solvable in polynomial time.
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
Nash Equilibria\sep  Lemke-Howson \sep Gale Evenness Strings \sep Complexity \sep Perfect Matching \sep Polynomial Time Algorithm
%% PACS codes here, in the form: \PACS code \sep code

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

%% \linenumbers

%% main text

%///////////////////////////////////////////Introduction///////////////////////////////////////////////////////////////////////////////////
\section{Introduction}\label{intro}

After Nash proved the existence of mixed equilibria in finite strategic games in  in 1951 \cite{nash} recent research has addressed the complexity of the problem \textsc{Nash}, that is how hard is it to find an Nash equilibria of a bimatrix game.
Finding all Nash equilibria in a bimatrix games is NP-complete, see \cite{gz}, but only recently it was shown that finding one Nash equilibrium  belongs to the interesting complexity class PPAD, see Daskalakis, Goldberg and Papadimitriou \cite{dgp} and  Chen and Deng \cite{cd}.
The complexity class PPAD includes function problems which are known to have a solution such as \textsc{End of the Line} and \textsc{Brouwer} \cite{ppad}.
Intuitively, it is the class of problems in which, given a source of a directed path, we are asked to find a sink or a nonstandard source.
The PPAD-completeness of \textsc{Nash} wats quite an unexpected result since a NE of a zero-sum game can be efficiently found by solving a minmax problem \cite{vN} via a linear program in polynomial time \cite{k}.


%The complexity results were proven by
%Daskalakis, Goldberg and Papadimitriou \cite{dgp} and  Chen and Deng \cite{cd} showed that \textsc{Nash} is PPAD-complete for all bimatrix games,
The classical algorithm to find an Nash equilibrium (NE), the Lemke-Howson (LH) algorithm \cite{lh} finds a NE by pivoting along the edges of the best response polytopes, derived from a bimatrix game, until it terminates at a NE.
This algorithm computes a NE efficiently in most games but Savani and von Stengel \cite{svs} showed that it displays exponential running time for a special class of games, derived from dual cyclic polytopes.
These polytopes can be obtained by taking the convex hull of the points on a moment curve. The resulting best response polytopes can then be fully described by an $n$-string of labels $l$, where each label corresponds to a facet of the polytope.
A vertex of the polytope is represented by a bit string $s$ if and only if $s$ fulfills the \emph{Gale evenness condition} (GEC), stating that a maximal substring of only 1's in $s$ must have even length, see \cite{gale}.
A one in the bit string indicates whether a vertex is on the facet associated with the label from $l$.

A NE in the bimatrix games corresponds to a vertex in the best response polytope which is \emph{fully labeled}, that is every facet of $l$ is labeled exactly once.
As vertices of the polytope can be described by bit strings which fulfill the GEC, we only need to consider finding a fully labeled string corresponding to a NE of the bimatrix game.
Bit strings which satisfy the GEC and fully label the corresponding label string are referred to as \emph{Gale strings}.
The decision problem \textsc{Gale} answers the questions whether a string of labels has an associated Gale string.
Clearly, there exist a Gale string for the string of labels derived from the best response polytopes of a bimatrix game, a NE of the game.

For this subclass of games, instead of finding a NE by pivoting in the best reply polytopes we only need to consider a string of labels and find a NE via a version of the LH algorithm, the Lemke-Howson for Gale (LHG) algorithm.
Similarly to the LH algorithm the LHG algorithm starts with a trivial Gale strings, the artificial equilibrium, and finds another distinct Gale string, a NE of the game.

We refer to the problem of finding another Gale string $s$ for the string of labels $l$, provided we are given one Gale string for $l$ as \textsc{Another Gale String}.
For the subclass of games derived from dual cyclic polytopes the LHG-algorithm displays exponential running time for some special examples \cite{svs}.
So finding another Gale string can take exponentially many steps via the LHG-algorithm.
Due to the exponential example it was conjectured that the problem of \textsc{Another Gale String} is PPAD-complete.
This would in turn have provided an elegant and traceable proof stating that \textsc{Nash} is PPAD-complete, proved by \cite{cd}\cite{dgp} by reducing \textsc{Brouwer} to an approximate version of \textsc{Nash}.  % references as in Bernhards paper,FOCS.

In this paper we prove that \textsc{Gale} and \textsc{Another Gale string} are polynomially decidable and solvable.
We prove the fist part by reducing \textsc{Gale} to \textsc{Perfect Matching}, which was shown to be in P by Edmonds \cite{edm}.
The idea of the reduction is to translate a string of labels $l$ into a graph $G$: the vertices in the graph correspond exactly to the labels in $l$ and an edge is placed between two vertices if the labels are neighbors in $l$.
This construction of $G$ assures that the graph has a perfect matching if and only if there exists a Gale string $s$ corresponding to $l$.
Using Edmonds's beautiful ``Paths, Trees, and Flowers'' algorithm \cite{edm} we can find one perfect matching in $G$ and thus one Gale string, in case the graph omits one.
By extending the construction of the graph to multigraphs we show \textsc{Another Gale String} is polynomially solvable, making it a member of P.
This implies that computing all NE in bimatrix games generated by dual cyclic polytopes can solved in polynomial time.
So far these are the only known games where the LH algorithm exhibits exponential running time.

Furthermore, we show via the LHG algorithm \textsc{Another Gale string} is a member of PPAD, although at this point is very unlikely to be PPAD-complete -- since it would imply that PPAD $=$ P.



%///////////////////////////////////////////Nash Equilibria and Gale Strings//////////////////////////////////////////////////////////////
\section{Gale Strings and Nash Equilibria}\label{nashgale}
\noindent In this section we introduce the problems \textsc{Gale} and \textsc{Another Gale string} and connect them to algorithmic game theory.
Given an $n$-string of labels, $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d< n$, an associated bit string $s \in \left\{0,1\right\}^n$ is called a \emph{Gale string} (or Gale bit string) if it satisfies:
\begin{enumerate}
\item \emph{Gale Evenness Condition} (GEC): all maximal substrings of 1's in $s$ with indices considered modulo $n$  %is this a good formal definition?
have even length;
\item \emph{Fully Labeled Condition} (FLC): $\left\{l(i)|s(i) = 1\right\} = \left\{1,\ldots,d\right\}$.
\end{enumerate} % this is implicit in the above: the number of 1's in $s$ is equal to $d$ and

\noindent where we set $kn\mod n = n$ for all integers $k$.

The first condition states that a substring of $s$ of the form $01\cdots 10$ has even length, so that 0110, 011110, etc., are allowed, but not 010, 01110, and so on.
In other words, a maximal substring of 1's, called a \emph{run}, must have an even number of 1's.
By considering the indices of $s$ modulo $n$ we allow odd maximal substrings of 1's at both ends of $s$ by  ``gluing'' them together to form an even substring.  % of  the form $01\cdots 10$.% - we call this the cyclic symmetry of the Gale evenness condition
The second condition states that each label is marked with exactly one 1 in the associated bit string $s$, thus fully labeling $l$.
Let $G(l)$ be the set of Gale strings corresponding to an $n$-string of labels $l$.
%(all this is inlcuded in Gale string.)of length $n$ with $d$ ones which fully label $l$ and that satisfy the Gale evenness condition. %Simply, $G(l)$ is the set of all bit strings of length $n$ with $d$ 1's such that all 0's are separated by an even number of 1s; no strings of the form $01^k0$ for $k$ odd.

\begin{example}{For the string of labels $l = 1123143$ the set of Gale strings is $G(l) = \left\{ 0110011, 0011110\right\}$.
The string of labels $l = 123432$ has associated Gale strings $s_1 = 111100$, $s_2 = 110110$, $s_3 = 100111$ and $s_4 = 101101$ (note the ``glued ends'' in the last two).
Conversely, for the string of labels $l = 121314$, $G(l)$ is empty.
}\end{example}

A natural question is: given an $n$-string of labels $l$ does it have an associated Gale string? That is, is $G(l)$ non empty? We refer to this as the \textsc{Gale} decision problem, defined as follows.\\

\noindent \textsc{Gale}\\
\textbf{Input}: \ $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d<n$.\\
\textbf{Question}: \ Does $l$ have a Gale string $s$?\\


\noindent A second question, motivated from algorithmic game theory, is, given a string of labels $l$ and Gale bit string $s$, how hard is it to find another Gale bit string? \\

\noindent \textsc{Another Gale String}\\
\textbf{Input}: \ $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d\leq n$, a Gale bit string $s$ associated with $l$.\\
\textbf{Output}: \ Another Gale string  $s'\neq s$ associated with $l$.\\

Finding another Gale string is motivated by computing an NE via the classic Lemke-Howson (LH).
This algorithm is efficient for most bimatrix games, but for a special class of games derived from dual cyclic polytopes it needs exponentially many steps to find an NE.
These games can be described by $n$-strings of labels and the problem of finding a NE is exactly the problem of \textsc{Another Gale String}.
We now describe the relationship between these games and Gale strings, for more detail see \cite{svs}.

\begin{comment}
For bimatrix $(A,B)$ where A and B are $m \times n$ payoff matrices for player I and player 2, a mixed strategy for player I is a probability vector $x \in \mathbb{R}^m$ and mixed strategy for player II a probability vector $y \in \mathbb{R}^n$.
\end{comment}

The special class of bimatrix games with $d$ strategies for each player are derived from from dual cyclic polytopes in dimension $d$ with $2d$ facets.
These polytopes can be obtained by taking the convex hull of $2d$ points on the moment curve. Re-interpreting and resizing this polytope gives the dual cyclic polytope for player I
$$P'' = \left\{z \in \mathbb{R}^d | c_i^T z \leq  1 \leq i \leq 2d \right\},$$
where $c_i \in \mathbb{R}^d$.
The vertices of $P''$ are exactly bit strings which correspond to the $2d$-string of labels $l$, where the labels are taken from the set $\left\{1,...,d\right\}$, and which satisfy the GEC.
A bit $s(i)$ equal to 1 indicated that the vertex is on the $l(i)$th facet of the polytope.
The best reply polytope $P$ for player I is derived by a suitable affine transformation which rearranges the labels in $P''$ such that the first $d$ labels correspond to the pure strategies of player I.
In similar fashion we derive the best reply polytope $Q$ for player II where the second $d$ labels correspond to the pure strategies of player II.
The other labels of the two strings describe the game. Concatenating the two label strings we obtain a $4d$-string of labels $l$, where the first $d$ and last $d$ labels correspond to the pure strategies of player I and II, respectively.

Nash equilibria of a bimatrix games are exactly Gale strings of $l$, apart from the bit string with $d$ 1's on both ends. This special bit string corresponds to a trivial ``artificial'' Nash equilibrium which assigns zero probability to all pure strategies of both players.
This Gale string acts as the starting point of the LH and and Lemke-Howson for Gale (LHG) algorithm.
The problem \textsc{Another Gale String} is therefore motivated from the problem of finding a non-trivial NE from the artificial Gale string.
In the next section we describe the Lemke-Howson for Gale pivoting algorithm and analyze its complexity.

%///////////////////////////////////////////Finding a Gale String /////////////////////////////////////////////////////////////////////////
\section{The Lemke-Howson for Gale Algorithm}

In this section we will prove that \textsc{Another Gale string} is a problem in the complexity class PPAD (Polynomial Parity Argument, Directed version), first introduced by Papadimitriou in 1994 \cite{ppad} together with the closely related class PPA (Polynomial Parity Argument).
We refer to Papadimitriou's article for the original formal definition of PPA and PPAD: for our scope we will consider PPAD as the class of problems reducible to

\noindent \textsc{End of the line}\\
\textbf{Input}: Two circuits $S$ and $P$ with $n$ input bits and $n$ output bits such that $P(0^n)=0^n\neq S(0^n)$.\\
\textbf{Output}: An input $x$ such that $P(S(x))\neq x$ or $S(P(x))\neq x\neq 0^n$\\

\noindent that is, the class of problems reducible to ``given a directed graph in which each node has indegree and outdegree of at most one and an unbalanced node, find another unbalanced node''.
PPA will then be the  class of problems reducible to ``given a graph of degree at most 2 and a node with odd degree, find another node of odd degree''.
%(a more formal definition? wikipedia adds "no isolated vertices" - I am not sure it is fundamental, they should be just unreacheable.)
Note that although PPAD $\subseteq$ PPA it is not known whether this relationship holds with equality.

Our first theorem states

\begin{theorem}\label{PPA}
{\textsc{Another Gale string} is in PPA.}
\end{theorem}

To prove the theorem we will introduce an algorithm, a variation on the Lemke-Howson algorithm that will pivot from one Gale string (that will correspond to a Nash equilibrium) to another.
%should we include the idea of artificial NE here? or just leave it like this, considering the artificial NE as other NEs?
We start by explaining what we mean by a pivot.
Suppose we are given an $n$-string $l$, a corresponding Gale string $s$ and a position $i \in \left\{1,\ldots,n\right\}$ which satisfies $s(i) = 1$.
We first set $s(i) = 0$, i.e.\ we \emph{drop} the label $l(i)$.
By the GEC, either to the left or the right of $s(i)$, there is an odd run of 1's.
We choose the side of $s(i)$ adjacent to where the odd run is and invert the first 0 to the left or right of the run, hence \emph{picking} up a new label.
We refer to this as \emph{pivoting} the label $l(i)$, as we pivot the 1 associated with $l(i)$ across the odd run.
Clearly the GEC is still satisfied after a pivot, however $l$ may not be fully labeled anymore as one label may be duplicate and thus one label missing.
We call a bit string which satisfies the GEC and where exactly one label is duplicate an \emph{almost Gale} string.
%That is, an almost Gale string satisfies the Gale evenness condition from before and the almost labeled condition. this is double
That is, an almost Gale string $s$ satisfies the GEC; furthermore the number of 1's in $s$ is equal to $d$ and $|\left\{l(i)|s(i) = 1\right\}|=d-1$.
%That is the number of 1's in $s$ is equal to $d$ and $\left\{l(i)|s(i) = 1\right\} \subset \left\{1,\ldots,d\right\}$ with $|\left\{l(i)|s(i) = 1\right\}|=d-1$. second part is follows from the last condition.
\begin{comment}
\begin{enumerate}
\item (\emph{Gale evenness condition}) all maximal substrings of 1's in $s$ with indices considered modulo $n$  %is this a good formal definition?
have even length;
\item (\emph{almost labeled condition}) the number of 1's in $s$ is equal to $d$ and $\left\{l(i)|s(i) = 1\right\} \subset \left\{1,\ldots,d\right\}$ with $|\left\{l(i)|s(i) = 1\right\}|=d-1$.
\end{enumerate}
\end{comment}

A pivot for an almost Gale string is defined similarly as dropping a duplicate label, assuring that the resulting string is again an almost Gale string or Gale string.  % must not pick up a new label for some strings
In a Gale string we may drop any label $l(i)$ which satisfies $s(i) = 1$.
We refer to these as \emph{free} labels.

Note that a pivot is reversible.
Suppose we just picked up a label $l(i)$ by dropping a label $l(j)$.
Clearly, $s(i)$ must be at the end of a run and $s(j)$ is equal to 0 and adjacent to the opposite side of the run where $l(i)$ was picked up.
By pivoting $l(i)$ we must pick $l(j)$, making the pivot reversible.
We now describe the Lemke-Howson for Gale algorithm,

\begin{algorithm}\label{pivot}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetNoline
\Input{A $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d< n$, a Gale string $s$ associated with $l$.}
\Output{A Gale string $s'\neq s$ associated with $l$.}
\BlankLine

pivot a free label of s;\\ %pick $i \in [n]$ s.t. $s(i) = 1$ and pivot $l(i)$;\\
\While{ ($s$ is an almost Gale string) }{
pivot the duplicate label, not picked up by the previous pivot;
}
\Return $s' = s$

\caption{Lemke-Howson for Gale Algorithm}
\end{algorithm}

As there are only a finite number of possible bit strings for each label string and if cycling is not possible the algorithm must terminate by finding another Gale string in a finite number of steps.
Cycling is not possible due to the following observations.
Suppose the algorithm returns to a bit assignment of $s$ other than the initial Gale string.
Then at this bit assignment of $s$, because each pivot is reversible, we would have to be able to pick up two labels.
This, however, is ruled out by the GEC as only one of the adjacent runs of the dropped label is odd.
Returning to initial position is only possible by reversing the initial pivot which is not allowed.
The only free choice we have is at the beginning of the algorithm where we drop one free label.
From then on the process of the algorithm is uniquely determined, thus terminating in a finite number of steps at another Gale string. As this initial choice is somewhat arbitrary the resulting Gale strings and NE for different first steps can vary.

By analysing the path created by the LHG algorithm we show that \textsc{Another Gale string} is a member of PPA.

\begin{comment}
%sentence too long
Intuitively, PPAD is the class of problems that are solved because in any directed graph with indegree and outdegree at most one if there is a \emph{standard source} there must be a sink and there also might be another source, that is the class of problems that are solved by moving on a directed graph of maximum indegree and outdegree 1 to find a sink or a nonstandard source.
On the other hand, PPA is the class of problems that are solved because in any graph with vertices of degree at most two if there is a vertex of degree one there must be another.

% we dont use the formal definition from here on, so why include it.
More formally, \cite{ppad} defines the class PPAD as the closure under reduction of the problems~$\mathcal{A}$ defined as follows: let $M$ be a polynomial-time deterministic Turing machine; let~$x$ be an input for~$\mathcal{A}$.
The \emph{configuration space} is $C(x)=\Sigma^{p(|x|)}$, the set of all strings of length at most polynomial in the size of~$x$ for a given polynomial~$p$.
Given $c\in C(x)$, the Turing machine $M$ outputs in polynomial time $M(x,c)$, which is an ordered pair of configurations in $C(x)$, a single configuration or the empty set.
We say that configuration~$c$ is the \emph{predecessor} of configuration~$c'$ if~$c$ is the first component of $M(x,c')$ and~$c'$ is the second component of $M(x,c)$; in this case we also say that~$c'$ is the \emph{successor} of~$c$.
Furthermore, we set $M$ such that $M(x,0\cdots0)=\{1\cdots1\}$ and $0\cdots0$ is the first component of $M(x,1\cdots1)$.
The relation ``to be a predecessor'' describes a graph~$G(x)$ with vertices all the configurations~$c$, such that for every configuration~$c$ we have $\mathrm{indegree}(c)+\mathrm{outdegree}(c)=|M(x,c)|$ and both~$\mathrm{indegree}(c)$ and~$\mathrm{outdegree}(c)$ are not greater than~$1$; furthermore we have one \emph{standard source}~$0\cdots0$.
Problem~$\mathcal{A}$ associated with~$M$ is the search problem: ``given $x$, find a node of~$G(x)$ other than~$0\cdots0$ with $\mathrm{indegree}+\mathrm{outdegree}=1$''.
The class PPA is defined in an analogous way, only the configurations are non-ordered pairs.


An example of a graph implicit in a PPAD problem could be
\begin{comment}
\begin{displaymath}
\xymatrix{
  0^n \ar[r] & 1^n \ar[r] & c_1 \ar[r] & c_2 & c_3 & c_4\ar@/^/[r] & c_5\ar@/^/[l] \\
}
\end{displaymath}

\noindent Looking at this graph we have $M(x,0\cdots0)=\{1\cdots1\}$, $M(x,1\cdots1)=(0\cdots0,c_1)$, $M(x,c_1)=(1\cdots1,c_2)$, $M(x,c_2)=\{c_1\}$; then $M(x,c_3)=\varnothing$ (nothing precedes nor follows $c_3$); then $M(x,c_4)=(c_5,c_5)$ and $M(x,c_5)=(c_4,c_4)$ ($c_4$ and $c_5$ form a cycle -- they are both successor and predecessor of each other).
The standard source of the graph is~$0^n$ and its sink is $c_2$.
\end{comment}

The steps taken by the LHG algorithm generate an undirected path which starts at the initial Gale string and which ends at another Gale string, thus making LHG a member of PPA.

We will now refine theorem \ref{PPA} to show that

\begin{theorem}\label{PPAD}
{\textsc{Another Gale string} is in PPAD.}
\end{theorem}


In order to prove that LHG is a member of PPAD we need to add an orientation, so that a directed path is generated by the algorithm.
That is at any point of the algorithm we should be able to decide only from considering the current configuration of $s$ what the previous pivot was and which of the duplicate labels we have to pivot next.
We now describe how to embed an orientation for each configuration.

Consider the substring $l'$ of $l$ where a label $l(i)$ is present in $l'$ if $s(i) = 1$, e.g. for $l = 123432$ and $s = 011110$ the substring $l'$ is $2343$.
If $l'$ is obtained from a Gale string, the \emph{sign} of $l$ is positive (negative) if the number of inversions in $l'$ is even (odd).
This describes the orientation of the input and thus the start of the algorithm.

In case $s$ is almost Gale (we are somewhere in the middle of the path) $l'$ has a duplicate label.
To obtain the sign of $l'$ for this case, let $l'_1$ and $l'_2$ be obtained from $l'$ by substituting the missing label for the different duplicate labels in $l'_1$ and $l'_2$, respectively. %and the old duplicate label in $l'_2$.
The sign of $l'_1$ and $l'_2$ is positive (negative) if the number of inversions in $l'_1$ and $l'_2$ is even (odd).
It is important to note that $l'_1$ and $l'_2$ have always opposite orientations, since each can be obtained from the other by exchanging two elements -- the duplicate label and the missing label of $l$. % $l'_1$ and $l'_2$ are fully labeled.

\begin{example}{
Given the string of labels $l = 123432$ the Gale bit string $s_1 = 111100$ has positive sign as $l'_1 = 1234$ has no inversions. For $s_2 =  110110$ and $s_3 = 100111$, $l$ has negative sign since there is one inversion in $l'_2 = 1243$ and three inversions in $l'_3 = 1432$. Finally, for $s_4 = 101101$, $l$ has positive sign since there are two inversions in $l'_4 = 1342$.
For the almost Gale string $s = 011110$ the associated string of labels is $l'= 2342$. This has positive or negative sign depending on whether we consider $l'_1 = 2341$ or $l'_2 =1342$.
}\end{example}

A pivot from a Gale or an almost-Gale string, %corresponding to the string $l'_1$
where the ``old'' duplicate label is substituted by the missing label, changes the sign of the new string. This is because the pivoting 1 will ``jump'' over an odd number of 1's.
We modify the LHG algorithm, see algorithm \ref{pivotdirection}, to incorporate a direction for the resulting path, visible at each step, resulting in a change of sign between each step.
Note that our orientation of the path recalls the orientation of Todd (see \cite{todd}) for primoids and duoids, which in turn is a generalization of Shapley's (see \cite{shapley}) ``sense of direction'' on the paths given by the LH algorithm.

\begin{comment}
This is done by considering the sign of the permutations  in the string of the labels to which correspond the 1's in the Gale or almost-Gale string.
For a Gale string the definition of the sign is straightforward: it is positive if the number of inversions in the string is positive, odd otherwise.
In the case of an almost-Gale string, we have two associated strings of labels to which we can define the sign as the number of inversions: one is obtained substituting the missing label to the ``new'' duplicate label, the one we have just found with the pivot, and the other is obtained substituting it to the ``old'' duplicate label.
It is important to note that these two strings have opposite orientation, since each one can be obtained from the other by exchanging two elements -- the duplicate label and the missing label.


\begin{example}{
Given the string of labels 123432 we say that the Gale bit string 111100 has positive sign, since there are no inversions in 1234; 110110 will have negative sign, since there is one inversion in 1243, as will 100111, since there are three inversions in 1432; finally, 101101 will have positive sign since there are two inversions in 1342.

The almost-Gale string 011110, associated with the string of labels 2342, can have negative sign if we consider the string 2341 and positive sign if we consider the string 1342.
}\end{example}
\end{comment}

%We can therefore modify the LHG algorithm in order to give the resulting path a direction, visible at each step: we alternate the signs in each step of the algorithm.
\begin{algorithm}\label{pivotdirection}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetNoline
\Input{A $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d< n$, a Gale string $s$ associated with $l$.}
\Output{A Gale string $s'\neq s$ associated with $l$.}
\BlankLine

pivot a free label of s;\\ %arbitrarily pick $i \in [n]$ s.t. $s(i) = 1$ and pivot $l(i)$;\\
\While{ ($s$ is an almost Gale string) }{

\uIf{($sign(l'_1) = sign(s))$}{pivot the label in $l'_1$, substituted by the missing label;}
\uElse{pivot the other duplicate label;}
}
\Return $s' = s$
\caption{LHG Directed Algorithm}
\end{algorithm}


\begin{comment}
\begin{algorithm}\label{pivotdirection}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetNoline
\Input{A $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d< n$, a Gale string $s$ associated with $l$.}
\Output{A Gale string $s'\neq s$ associated with $l$.}
\BlankLine

pivot a free label of s;\\ %arbitrarily pick $i \in [n]$ s.t. $s(i) = 1$ and pivot $l(i)$;\\
\While{ ($l$ is not fully labeled by $s$) }{
calculate which duplicate label,  if substituted with the missing label, gives the almost-Gale string the same sign as $s$;\\
pivot this duplicate label;\\
}
\caption{LHG Pivot Algorithm}
\end{algorithm}
\end{comment}


\begin{example}{
We consider again $l=123432$. If we start from $s=111100$, with positive sign, by pivoting $l(1)= 1$ we obtain $s = 011110$.
Now we have two possible signs: negative for $l'_1 = 2341$ and positive for $l'_2 = 2143$.  For the former the duplicate label is the ``new'' label, for the latter the ``old'' label. We pivot the old label, $l(3)$, which yields the Gale string $s = 110110$ (negative sign) and the algorithm terminates with a solution.
}\end{example}

In general, starting with a Gale string with positive sign we obtain the following path:
%\begin{comment} % dont delete, just comment
\begin{displaymath}
\xymatrix{
+ \mbox{  (Gale string)}\ar[rr]|-{first\ pivot}			&	& - \mbox{  (almost-Gale, ``new label'')} \ar[dll]|-{orientation}\\
+ \mbox{  (almost-Gale, ``old label'')}\ar[rr]|-{pivot}	&	& \ldots\ar[dll]|-{orientation}\\
\ldots\ar[rr]|-{pivot}									&	& - \mbox{  (another Gale)}\\
}
\end{displaymath}
%\begin{comment}

\noindent When starting with a string with negative sign the signs are simply the opposite and equivalently, the direction of the path is inverted.
Therefore,
%\begin{remark}{
the endpoints of the algorithm always have opposite orientation.
As already stated by Shapley \cite{shapley}, since the starting point of the LH algorithm has positive orientation, we know that using the LH algorithm we will always find Nash equilibria of negative sign.

Note that, in general, if we construct a graph with possible Gale strings as vertices and connect the Gale string that can be derived from each other, following the LHG algorithm this graph is bipartite into strings of positive and negative sign.
This shows that the number of NE found by the LHG-algorithm is always odd, with one ``negative sign'' equilibrium more -- see also \cite{shapley}.
%}\end{remark}

\begin{example}{Let us consider $l=12342314$. The possible Gale strings are derived from each other by dropping different labels as follows:
%\begin{comment}
\begin{displaymath}
\xymatrix{
11110000\ar[r]^1\ar[dr]^{2,4}\ar[ddr]				& 00011110\ar[l]\ar[dl]\ar[ddl] \\
01100011\ar[ur]_2\ar[r]\ar[dr]|-4	& 11100001\ar[ul]\ar[l]\\
00001111\ar[uur]\ar[r]_{1,2}	& 10001101\ar[uul]\ar[ul]\ar[l]\\
}
\end{displaymath}


Note that the graph is a bipartite graph -- but it is not a complete bipartite graph: to reach 1110001 from 0000111 we must apply the algorithm three times.
To our knowledge it is an open question if the graph has to be connected.
}\end{example}
%\end{comment}

This brings us back to the connection with Game Theory: a result of PPAD-completeness on \textsc{Another Gale String} would yield a traceable proof via the LHG algorithm to the result that \textsc{Nash} is PPAD-complete, whereas \cite{cd} and \cite{dgp} use an approximated version of the Nash equilibrium.
A good reason why finding a second Gale string was believed to be PPAD-complete arised from a bimatrix game, generated from a dual cyclic polytopes, where the LHG-algorithm takes exponentially many steps to find an NE, see \cite{svs}.
The question remains open but, as we will see, it is very unlikely that the answer is positive. In the next chapter we show that \textsc{Gale} and  \textsc{Another Gale String} are both members of P.


%///////////////////////////////////////////Finding a Gale String /////////////////////////////////////////////////////////////////////////
\section{The Complexity of \textsc{Gale} and  \textsc{Finding Another Gale String}}\label{gale}

% As with any decision problem the natural question to ask is in which complexity class \textsc{Gale} is.
\noindent We show that \textsc{Gale} is decidable in polynomial time, and thus a member of P, via a reduction to \textsc{Perfect Matching}, the decision problem defined as\\

\noindent \textsc{Perfect Matching}\\
\textbf{Input}: Graph $G = (V,E)$.\\
\textbf{Question}: Does there exist a set $M\subseteq E$ of pairwise non-adjacent edges such every vertex $v \in V$ is incident to exactly one edge of $M$?\\

Clearly, a graph can only have a perfect matching if the number of vertices is even.
Edmonds \cite{edm} first introduced a polynomial algorithm which finds a maximal matching in a graph, provided it has one, in polynomial time.
We can use this algorithm to decide \textsc{Perfect Matching} in polynomial time.
Before we give a polynomial reduction from \textsc{Gale} to \textsc{Perfect Matching}, which shows that \textsc{Gale} is polynomially decidable, let us note two interesting properties of Gale strings.

\begin{lemma}\label{norep}{Let $l=l(1)l(2)\cdots l(n)$ be a string as in an arbitrary instance of \textsc{Gale} and let $l(i)=l(i+1)$ for some $i \mod n$.
Let $l'$  be the $(n-1)$-string obtained by deleting $l(i)$, that is $l'=l(1)\cdots l(i-1) l(i+1) \cdots l(n)$.
Then there is a a one-to-one correspondence between the Gale strings associated with $l$ and those associated with $l'$.}
\end{lemma}

\begin{proof}{
Assume w.l.o.g.\ that $i=1$, so that $l'=l(2)\cdots l(n)$.
Let $s=s(1)\cdots s(n)$ and $s'=s'(1)\cdots s'(n-1)$ be the Gale strings associated with $l$ and $l'$ respectively.

Suppose we know $s$.
Note that only one $s(i)$ for $i=1,2$ is  equal to 1.
If either $s(1)$ or $s(2)$ is equal to $1$ take $s'=1 s(3)\cdots s(n)$.
If both are equal to 0 take $s'=0 s(3)\cdots s(n)$.
In both cases, the label $l(1)=l(2)$ is still labeled -- by $s'(1)$ in the former and elsewhere in latter.
As we eliminate only a 0, the GEC is still satisfied.

Conversely, suppose we know $s'$.
If $s'(1)$ is equal to 0, take $s=0s'(1)\cdots s'(n-1)$$=00s'(2)\cdots s'(n-1)$.
The GEC still holds, because we only add a zero next to another zero.
If $s'(1)$ is equal to 1, it is part of an even run of ones; set $s=01s'(2)\cdots s'(n-1)$ or $s=10s'(2)\cdots s'(n-1)$ according to which one retains the GEC.
This is always possible because we ``break'' the even run in two even runs by introducing a 0.
In both cases it is guaranteed that $l(1)=l(2)$ is labeled exactly once, as in $s'$.
This concludes the proof of the lemma.
}\end{proof}

From this point forward we will only consider strings of labels $l$ with $l(i \mod n)\neq l((i+1) \mod n)$. %, with the convention $kn\mod n = n$ for every $k\in\mathbb{Z}$. see chapter 1.
Next we show that can disregards strings of labels with its ends ``glued together'' as long as we consider an augmented string, obtained by adding a constant number of labels to the original string.

\begin{proposition}{The Gale strings associated with the string $l=l(1)\cdots l(n)$ with indices taken modulo $n$ are in one-to-one correspondence with the ones associated with $l'=a l(1) \cdots l(n) b x ab x y$ with indices taken \emph{not} modulo $n$, where $a,b,x,y\notin \{1,\ldots,d\}$.}
\end{proposition}

\begin{proof}{
Let $s\in G(l)$ and $s'\in G(l)$.
Since $y$ appears only in one position, the corresponding position in the bit string $s'$ must be 1.
By parity the bit preceding is also equal to 1.
Any other bit in $s'$ corresponding to an occurrence of $x$ in $l'$ must be 0.
Again by parity the bits associated with $a$ and $b$, $s'(2)$ and $s'(n+3)$ are both equal to 0 and $s'(n+5)$ and $s'(n+6)$ are both equal to 1, or vice versa.
Now, all the strings $s$ in which the ends are not ``glued together'' are in one-to-one correspondence with all the $s'$ in the former case, whereas the the strings $s$ in which both ends have an odd number of 1's are in one-to-one correspondence with all the $s'$ in the latter.
This concludes the proof.
}\end{proof}

\begin{example}{
The string $l = 1234132$ has four corresponding Gale strings: $s_1 = 1111000$, $s_2 = 0111100$, $s_3 = 0001111$, and $s_4 = 1011001$. The corresponding string of labels without wrap-around is $ l' = a1234132bxabxy$ with Gale strings $s'_1 =  0\mathbf{1111000}001111$, $s'_2 =  0\mathbf{0111100}001111$, $s'_3 =  0\mathbf{0001111}001111$, and $s'_4 =  1\mathbf{1011001}100011$.
}\end{example}

We now state our theorem.

\begin{theorem}\label{galedecision}{\textsc{Gale} is polynomially decidable.}
\end{theorem}

\begin{proof}{
We transform \textsc{Gale} to \textsc{Perfect Matching} as follows.
Let $l$ be the $n$-string in the set $\left\{1,\ldots,d\right\}^{n}$ as in an arbitrary instance of \textsc{Gale}. We must construct the graph $G = (V,E)$ such that $G$ has a perfect matching if and only if $l$ has a Gale string.
Specify the graph $G = (V,E)$ by setting $V = \left\{1,\ldots,d\right\}$ and $E =\{(u,v)| u = l(i) $ $\mbox{and } v = l((i+1)\mod n)\mbox{ for }  i = 1,\ldots,n \}$, where we set $kn\mod n = n$ for all integer $k$.
In other words there exists an edge between two vertices in the graph exactly when they are neighbors somewhere in the string $l$ with ends ``glued together''.
Clearly the graph is polynomial in the size of the instance of \textsc{Gale}.

Now suppose that $G$ has a perfect matching.
Then there exist a set of pairwise non-adjacent edges $M\subseteq E$ such every vertex $v \in V$ is incident to exactly one edge of $M$.
Given $M$, construct $s$ as follows: if $(u,v) \in M$ then $uv$ are neighboring labels in $l$, by the construction of the graph.
As there might be multiple occurrences of $uv$ in $l$, find one such pair and set the corresponding bits in $s$ to 1.
As we are not considering strings with substrings $uu$, there are no loops $(u,u)$ in the graph or in the matching and therefore no duplicate labels. % hence there will be no doubly labeled $u$'s in the string $s$.
Since we set only adjacent pairs of bits to 11, clearly the GEC is satisfied.
The string is fully labeled since the matching is perfect and therefore every vertex is incident to exactly one edge in $M$.
If the corresponding graph does not have a perfect matching then it is impossible to construct a Gale String $s$.
This concludes the proof.
}\end{proof}

The function problem associated with \textsc{Gale} is\\

\noindent \textsc{Gale String}\\
\textbf{Input}: \ $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d< n$.\\
\textbf{Output}: \ An associated Gale string  $s$ or $s=0\cdots 0$ if such a string does not exist.\\

\noindent A solution to \textsc{Gale String} can be computed in polynomial time from the perfect matching (in case one exists) of the corresponding graph, see the proof of Theorem \ref{galedecision}. %by looking for one substring in $l$ corresponding to each edge of the matching found via Edmonds's algorithm in theorem \ref{galedecision} -- once we have the matching this will take at most $\frac{d}{2}{n}$ time.

\begin{corollary}\label{galefunction}{\textsc{Gale String} is polynomially solvable.}
\end{corollary}

Interestingly, while \textsc{Perfect Matching} is in P counting the number of perfect matchings of even a bipartite graph is $\sharp$P-complete \cite{val}. This implies that counting all Gale strings associated with a string of labels is also $\sharp$P-complete.



%///////////////////////////////////////////Finding a second Gale String is in P  ///////////////////////////////////////////////////
\section{Finding a second Gale String is in P }

We have seen that one approach to find a second Gale string, via the LHG algorithm, exhibits exponential running time for certain games.
We now show that a second Gale string can be found in polynomial time.
Using the transformation as in Theorem \ref{galedecision} and Edmonds's algorithms, given a string $l$ of labels we can find either at least one element $s\in G(l)$ or that $G(l)$ is empty.
In order to find another member of $G(l)$ we need to alter the transformation such that the corresponding graph allows multiple edges if there are repetitions of neighboring labels in $l$.

%\begin{comment}
\begin{example}{
For $l = 123234$ the corresponding multigraph has three distinct edges between vertex $2$ and $3$ allowing for four possible distinct perfect matchings. These correspond to the four Gale strings $s_1 = 100111$, $s_2 =  101101$, $s_3 = 111001$ and $s_4 = 110011$. That is, from

\begin{displaymath}
\xymatrix{
1\ar@{-}[r]				& 2 \ar@{-}@/^/[d]\ar@{-}@/_/[d]\\
4\ar@{-}[u] 			& 3\ar@{-}[u]\ar@{-}[l]\\
}
\end{displaymath}

\noindent we get

\begin{displaymath}
\xymatrix{
1\ar@{-}[r]				& 2 				& & 1 			& 2\ar@{-}@/_/[d]\\
4			 			& 3\ar@{-}[l] 		& & 4\ar@{-}[u] & 3\\
1						& 2					& & 1 			& 2\ar@{-}@/^/[d]\\
4\ar@{-}[u] 			& 3\ar@{-}[u]		& & 4\ar@{-}[u] & 3\\
}
\end{displaymath}
%\end{comment}
Furthermore, we can label each multiple edge $(u,v)$ according to the position of the substring $uv$ in $l$, i.e.\ $uv_1$ is the first occurrence in $l$.  %$uv$'s% that generated it among the different substrings

%\begin{comment}
\begin{displaymath}
\xymatrix{
1\ar@{-}[rr]			&	& 2 \ar@{-}@/^/[dd]^{23_2}\ar@{-}@/_/[dd]_{23_1}\\
& & \\
4\ar@{-}[uu]			&	& 3\ar@{-}[uu]|-{32}\ar@{-}[ll]\\
}
\end{displaymath}
}\end{example}
%\end{comment}

Note that the  multigraph corresponding to $l$ is a Euler graph, that is each vertex has an even degree.
Furthermore $l$ gives an Eulerian orientation of its corresponding Euler graph.
We now give a polynomial time algorithm for solving the problem\\
%TO DO: write something more about it, use it.

%\begin{remark}{
%By labeling the edges of the multigraph we make explicit the one-to-one correspondance between edges $(u,v)$ of the multigraph and substrings $uv$, so we can adapt Edmonds's algorithm to solve \textsc{Gale string} in polynomial time.\\
%}\end{remark} It's enough to take any substring - see above

\noindent \textsc{Another Gale string}\\
\textbf{Input}: \ $n$-string $l \in \left\{1,\ldots,d\right\}^{n}$ where $d$ is even and $d\leq n$, a Gale string  $s$ associated with $l$.\\
\textbf{Output}: \ Another Gale string  $s'\neq s$ associated with $l$.\\

\begin{theorem}{\textsc{Another Gale string} is polynomially solvable.}
\end{theorem}

\begin{proof}{
Construct a multigraph $G=(V,E)$ associated with $l$ as above, and  consider the matching $M=\{m_1,\ldots,m_{\frac{d}{2}}\}$ associated with $s$.
%Check if there are multiple edges associated with some $m_i$; if this is the case take one of these another edges instead of $m_i$. If not,
Consider $G_1=(V,E\setminus \{m_1\})$, and via the Edmonds's algorithm evaluate if $G_1$ has perfect matching.
If so, take $s'$ to be the string associated with this matching.
It is a Gale string because the matching is perfect, and it is not equal to $s$ because $m_1$ does not belong to its associated matching.
If $G_1$ does not have a perfect matching, consider $G_2=(V,E\setminus \{m_2\})$, and so on.
Since we know that at least two Gale strings exist, the algorithm will stop after at most $\frac{d}{2}$ steps.
This concludes the proof.
}\end{proof}

As finding all NE in bimatrix games generated by dual cyclic polytopes can be solved by Edmonds's algorithm this lemma follows.

\begin{lemma} Computing all NE in bimatrix games generated by dual cyclic polytopes can solved in polynomial time.
\end{lemma}

\noindent It is interesting to note that this class of games is the only known class of games for which the LH-algorithm exhibits exponential running time.

\newpage
\begin{thebibliography}{00}

\bibitem{cd} C. Xi, X.Deng, (2006). Settling the Complexity of Two-Player Nash Equilibrium. \emph{Proceedings of the 47th Annual IEEE Symposium on Foundations of Computer Science (FOCS) 2006}, pp 261--272.

\bibitem{dgp} C. Daskalakis, P. W. Goldberg and C. H. Papadimitriou, (2006). The complexity of computing a Nash equilibrium. \emph{Annual ACM Symposium on Theory of Computing 2006}, pp. 71--78.

\bibitem{dgp2} C. Daskalakis, P. W. Goldberg and C. H. Papadimitriou, (2009). The complexity of computing a Nash equilibrium. Commun.\ ACM 52, pp 89--97.

\bibitem{edm} J. Edmonds (1965), Paths, Trees, and Flowers. Canad. J. Math. 17, pp. 449--467.

\bibitem{gale} D. Gale (1963), Neighborly and cyclic polytopes. In: Convexity, Proc. Symposia in Pure Math., Vol. 7, ed. V. Klee, American Math. Soc., Providence, Rhode Island, pp. 225--232.

\bibitem{gz} I. Gilboa and E. Zemel. Nash and correlated equilibria: Some complexity considerations. Games and Economic Behavior, 1989.

\bibitem{k} L. G. Khachiyan, (1979). A polynomial algorithm in linear programming. \emph{Soviet Mathematics Doklady}, 20(1), pp. 191--194.

\bibitem{lh} C.E.Lemke, J.T. Howson, Jr. (1964). Equilibrium points of bimatrix games. \emph{Journal of the Society for Industrial and Applied Mathematics} 12, pp. 413--423.

\bibitem{nash} J. Nash, (1951). Noncooperative games. \emph{Annals of Mathematics, 54}, pp. 289--295.

\bibitem{ppad} C. H. Papadimitriou (1994), On the Complexity of the Parity Argument and Other Inefficient Proofs of Existence. In Journal of Computer and System Sciences 48, pp. 498--532.

\bibitem{svs} R. Savani, B. von Stengel (2006), Hard-to-Solve Bimatrix Games. Econometrica 74, pp. 397--429.

\bibitem{shapley} L. S. Shapley (1974), A Note on the Lemke-Howson Algorithm. Mathematical Programming Study, 1, pp. 175--189.

\bibitem{todd} M. J. Todd (1976), Orientation in Complementary Pivot Algorithms. Mathematics of Operations Research, vol. 1, no. 1, pp. 54--66.

\bibitem{val} L. G. Valiant (1979), The complexity of computing the permanent. Theoretical Computer Science 8, pp. 89--201.

\bibitem{vN}  J. von Neumann, (1928). Zur Theorie der Gesellschaftspiele, \emph{Mathematische Annalen}, 100, pp. 295--320.


\end{thebibliography}
\end{document}
\endinput
